// Package issuer provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package issuer

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	externalRef0 "github.com/trustbloc/vcs/pkg/restapi/v1/common"
)

// Defines values for InitiateOIDC4CIComposeRequestGrantType.
const (
	InitiateOIDC4CIComposeRequestGrantTypeAuthorizationCode                            InitiateOIDC4CIComposeRequestGrantType = "authorization_code"
	InitiateOIDC4CIComposeRequestGrantTypeUrnIetfParamsOauthGrantTypePreAuthorizedCode InitiateOIDC4CIComposeRequestGrantType = "urn:ietf:params:oauth:grant-type:pre-authorized_code"
)

// Defines values for InitiateOIDC4CIRequestGrantType.
const (
	InitiateOIDC4CIRequestGrantTypeAuthorizationCode                            InitiateOIDC4CIRequestGrantType = "authorization_code"
	InitiateOIDC4CIRequestGrantTypeUrnIetfParamsOauthGrantTypePreAuthorizedCode InitiateOIDC4CIRequestGrantType = "urn:ietf:params:oauth:grant-type:pre-authorized_code"
)

// CredentialConfigurationsSupported An object that describes specifics of the Credential that the Credential Issuer supports issuance of.
type CredentialConfigurationsSupported struct {
	// Claims For mso_mdoc and vc+sd-jwt vc only. Object containing a list of name/value pairs, where each name identifies a claim about the subject offered in the Credential. The value can be another such object (nested data structures), or an array of such objects.
	Claims *map[string]interface{} `json:"claims,omitempty"`

	// CredentialDefinition Object containing the detailed description of the credential type.
	CredentialDefinition *externalRef0.CredentialDefinition `json:"credential_definition,omitempty"`

	// CredentialSigningAlgValuesSupported Array of case sensitive strings that identify the algorithms that the Issuer uses to sign the issued Credential.
	CredentialSigningAlgValuesSupported *[]string `json:"credential_signing_alg_values_supported,omitempty"`

	// CryptographicBindingMethodsSupported Array of case sensitive strings that identify how the Credential is bound to the identifier of the End-User who possesses the Credential.
	CryptographicBindingMethodsSupported *[]string `json:"cryptographic_binding_methods_supported,omitempty"`

	// Display An array of objects, where each object contains the display properties of the supported credential for a certain language.
	Display *[]CredentialDisplay `json:"display,omitempty"`

	// Doctype For mso_mdoc vc only. String identifying the Credential type, as defined in [ISO.18013-5].
	Doctype *string `json:"doctype,omitempty"`

	// Format A JSON string identifying the format of this credential, i.e., jwt_vc_json or ldp_vc. Depending on the format value, the object contains further elements defining the type and (optionally) particular claims the credential MAY contain and information about how to display the credential.
	Format string `json:"format"`

	// Order Array of the claim name values that lists them in the order they should be displayed by the Wallet.
	Order *[]string `json:"order,omitempty"`

	// ProofTypesSupported Object that describes specifics of the key proof(s) that the Credential Issuer supports.
	ProofTypesSupported *map[string]ProofTypeSupported `json:"proof_types_supported,omitempty"`

	// Scope A JSON string identifying the scope value that this Credential Issuer supports for this particular credential.
	Scope *string `json:"scope,omitempty"`

	// Vct For vc+sd-jwt vc only. String designating the type of a Credential, as defined in https://datatracker.ietf.org/doc/html/draft-ietf-oauth-sd-jwt-vc-01
	Vct *string `json:"vct,omitempty"`
}

// CredentialDisplay defines model for CredentialDisplay.
type CredentialDisplay struct {
	BackgroundColor *string `json:"background_color,omitempty"`
	Locale          *string `json:"locale,omitempty"`
	Logo            *Logo   `json:"logo,omitempty"`
	Name            *string `json:"name,omitempty"`
	TextColor       *string `json:"text_color,omitempty"`
	Url             *string `json:"url,omitempty"`
}

// CredentialIssuanceHistoryData CredentialIssuanceHistoryData represents the credential issuance history array element.
type CredentialIssuanceHistoryData struct {
	// CredentialId Credential ID.
	CredentialId string `json:"credential_id"`

	// CredentialTypes JSON array of credential types.
	CredentialTypes []string `json:"credential_types"`

	// ExpirationDate Expiration Date.
	ExpirationDate *string `json:"expiration_date,omitempty"`

	// IssuanceDate Issuance Date.
	IssuanceDate *string `json:"issuance_date,omitempty"`

	// Issuer Issuer identifier.
	Issuer string `json:"issuer"`

	// ProfileVersion Issuer Profile version.
	ProfileVersion *string `json:"profile_version,omitempty"`

	// TransactionId Transaction ID.
	TransactionId *string `json:"transaction_id,omitempty"`
}

// CredentialResponseEncryptionSupported Object containing information about whether the Credential Issuer supports encryption of the Credential and Batch Credential Response on top of TLS
type CredentialResponseEncryptionSupported struct {
	// AlgValuesSupported Array containing a list of the JWE [RFC7516] encryption algorithms (alg values) [RFC7518] supported by the Credential and Batch Credential Endpoint to encode the Credential or Batch Credential Response in a JWT [RFC7519].
	AlgValuesSupported []string `json:"alg_values_supported"`

	// EncValuesSupported Array containing a list of the JWE [RFC7516] encryption algorithms (enc values) [RFC7518] supported by the Credential and Batch Credential Endpoint to encode the Credential or Batch Credential Response in a JWT [RFC7519].
	EncValuesSupported []string `json:"enc_values_supported"`

	// EncryptionRequired Boolean value specifying whether the Credential Issuer requires the additional encryption on top of TLS for the Credential Response. If the value is true, the Credential Issuer requires encryption for every Credential Response and therefore the Wallet MUST provide encryption keys in the Credential Request. If the value is false, the Wallet MAY chose whether it provides encryption keys or not.
	EncryptionRequired bool `json:"encryption_required"`
}

// CredentialStatus Credential status.
type CredentialStatus struct {
	Status string `json:"status"`
	Type   string `json:"type"`
}

// CredentialStatusOpt Options for issuing credential.
type CredentialStatusOpt struct {
	Type string `json:"type"`
}

// DeprecatedComposeOIDC4CICredential Deprecated. Use /issuer/profiles/{profileID}/{profileVersion}/interactions/initiate-oidc-compose. Model for composing OIDC4CI credential.
type DeprecatedComposeOIDC4CICredential struct {
	// Credential Raw Complete credential for sign and customization
	Credential *map[string]interface{} `json:"credential,omitempty"`

	// IdTemplate ID of the credential template.
	IdTemplate *string `json:"id_template"`

	// OverrideIssuer Override issuer.
	OverrideIssuer *bool `json:"override_issuer"`

	// OverrideSubjectDid Override credential subject did.
	OverrideSubjectDid *bool `json:"override_subject_did"`

	// PerformStrictValidation Perform strict validation.
	PerformStrictValidation *bool `json:"perform_strict_validation"`
}

// ExchangeAuthorizationCodeRequest Model for exchanging auth code from issuer oauth
type ExchangeAuthorizationCodeRequest struct {
	// ClientAssertion The value MUST contain two JWTs, separated by a "~" character. The first JWT is the client attestation JWT, the second is the client attestation PoP JWT.
	ClientAssertion *string `json:"client_assertion,omitempty"`

	// ClientAssertionType Specifies the method used to authenticate the client application to the authorization server (VCS). The only supported value is "urn:ietf:params:oauth:client-assertion-type:jwt-client-attestation". It indicates that the client must authenticate using OAuth 2.0 Attestation-Based Client Authentication method.
	ClientAssertionType *string `json:"client_assertion_type,omitempty"`

	// ClientId Client ID for VCS OIDC interaction.
	ClientId *string `json:"client_id,omitempty"`
	OpState  string  `json:"op_state"`
}

// ExchangeAuthorizationCodeResponse Response model for exchanging auth code from issuer oauth
type ExchangeAuthorizationCodeResponse struct {
	AuthorizationDetails *[]externalRef0.AuthorizationDetails `json:"authorization_details,omitempty"`
	TxId                 string                               `json:"tx_id"`
}

// InitiateIssuanceCredentialConfiguration An object that describes specifics of the Multiple Credential Issuance.
type InitiateIssuanceCredentialConfiguration struct {
	// ClaimData Required for Pre-Authorized Code Flow. VCS OIDC Service acts as OP for wallet applications
	ClaimData *map[string]interface{} `json:"claim_data"`

	// ClaimEndpoint Claim endpoint of the Issuer from where credential claim data has to be requested after successfully acquiring access tokens.
	ClaimEndpoint *string `json:"claim_endpoint"`

	// Compose Deprecated. Use /issuer/profiles/{profileID}/{profileVersion}/interactions/initiate-oidc-compose. Model for composing OIDC4CI credential.
	// Deprecated:
	Compose *DeprecatedComposeOIDC4CICredential `json:"compose,omitempty"`

	// CredentialDescription Credential description
	CredentialDescription *string `json:"credential_description,omitempty"`

	// CredentialExpiresAt Date when credentials should be consider as expired
	CredentialExpiresAt *time.Time `json:"credential_expires_at,omitempty"`

	// CredentialName Credential name
	CredentialName *string `json:"credential_name,omitempty"`

	// CredentialTemplateId Template of the credential to be issued while successfully concluding this interaction. REQUIRED, if the profile is configured to use multiple credential templates.
	CredentialTemplateId *string `json:"credential_template_id,omitempty"`
}

// InitiateIssuanceCredentialConfigurationCompose An object that describes specifics of the Multiple Credential Issuance.
type InitiateIssuanceCredentialConfigurationCompose struct {
	// Credential Raw Complete credential for sign and customization
	Credential *map[string]interface{} `json:"credential,omitempty"`

	// CredentialExpiresAt Date when credentials should be consider as expired
	CredentialExpiresAt *time.Time `json:"credential_expires_at,omitempty"`

	// CredentialOverrideId override for the ID field in credentialSubject. Supports templating.
	CredentialOverrideId *string `json:"credential_override_id"`

	// CredentialOverrideIssuer Override issuer.
	CredentialOverrideIssuer *bool `json:"credential_override_issuer"`

	// CredentialOverrideSubjectDid Override credential subject did.
	CredentialOverrideSubjectDid *bool `json:"credential_override_subject_did"`

	// CredentialPerformStrictValidation Perform strict validation.
	CredentialPerformStrictValidation *bool `json:"credential_perform_strict_validation"`
}

// InitiateOIDC4CIComposeRequest Model for Initiate OIDC Compose Credential Issuance Request.
type InitiateOIDC4CIComposeRequest struct {
	// AuthorizationDetails Customizes what kind of access Issuer wants to give to VCS.
	AuthorizationDetails *string `json:"authorization_details,omitempty"`

	// ClientInitiateIssuanceUrl URL of the issuance initiation endpoint of a Wallet. Takes precedence over client_wellknown request parameter. If both client_initiate_issuance_url and client_wellknown are not provided then response initiate issuance URL will contain custom initiate issuance URL in format openid-initiate-issuance://.
	ClientInitiateIssuanceUrl *string `json:"client_initiate_issuance_url,omitempty"`

	// ClientWellknown String containing wallet/holder application OIDC client wellknown configuration URL.
	ClientWellknown *string `json:"client_wellknown,omitempty"`

	// Compose An array of objects that describes specifics of the Multiple Credential Issuance.
	Compose *[]InitiateIssuanceCredentialConfigurationCompose `json:"compose,omitempty"`

	// GrantType Issuer can provide custom grant types through this parameter. This grant type has to be used while exchanging an access token for authorization code in later steps.
	GrantType *InitiateOIDC4CIComposeRequestGrantType `json:"grant_type,omitempty"`

	// OpState String value created by the Credential Issuer and opaque to the Wallet that is used to bind the sub-sequent authentication request with the Credential Issuer to a context set up during previous steps. If the client receives a value for this parameter, it MUST include it in the subsequent Authentication Request to the Credential Issuer as the op_state parameter value. MUST NOT be used in Authorization Code flow when pre-authorized_code is present.
	OpState *string `json:"op_state,omitempty"`

	// ResponseType Contains response type that issuer expects VCS to use while performing OIDC authorization request. Defaults to token.
	ResponseType *string `json:"response_type,omitempty"`

	// Scope Contains scopes that issuer expects VCS to use while requesting authorization code for claim data. Defaults to openid.
	Scope *[]string `json:"scope,omitempty"`

	// UserPinRequired Required for Pre-Authorized Code Flow. Boolean value specifying whether the issuer expects presentation of a user PIN along with the Token Request in a pre-authorized code flow.
	UserPinRequired *bool `json:"user_pin_required,omitempty"`

	// WalletInitiatedIssuance Boolean flags indicates whether given transaction is initiated by Wallet.
	WalletInitiatedIssuance *bool `json:"wallet_initiated_issuance,omitempty"`
}

// InitiateOIDC4CIComposeRequestGrantType Issuer can provide custom grant types through this parameter. This grant type has to be used while exchanging an access token for authorization code in later steps.
type InitiateOIDC4CIComposeRequestGrantType string

// InitiateOIDC4CIRequest Model for Initiate OIDC Credential Issuance Request.
type InitiateOIDC4CIRequest struct {
	// AuthorizationDetails Customizes what kind of access Issuer wants to give to VCS.
	AuthorizationDetails *string `json:"authorization_details,omitempty"`

	// ClaimData Deprecated: Use CredentialConfiguration instead. Required for Pre-Authorized Code Flow. VCS OIDC Service acts as OP for wallet applications
	// Deprecated:
	ClaimData *map[string]interface{} `json:"claim_data"`

	// ClaimEndpoint Deprecated: Use CredentialConfiguration instead. Claim endpoint of the Issuer from where credential claim data has to be requested after successfully acquiring access tokens.
	// Deprecated:
	ClaimEndpoint *string `json:"claim_endpoint,omitempty"`

	// ClientInitiateIssuanceUrl URL of the issuance initiation endpoint of a Wallet. Takes precedence over client_wellknown request parameter. If both client_initiate_issuance_url and client_wellknown are not provided then response initiate issuance URL will contain custom initiate issuance URL in format openid-initiate-issuance://.
	ClientInitiateIssuanceUrl *string `json:"client_initiate_issuance_url,omitempty"`

	// ClientWellknown String containing wallet/holder application OIDC client wellknown configuration URL.
	ClientWellknown *string `json:"client_wellknown,omitempty"`

	// CredentialConfiguration An array of objects that describes specifics of the Multiple Credential Issuance.
	CredentialConfiguration *[]InitiateIssuanceCredentialConfiguration `json:"credential_configuration,omitempty"`

	// CredentialDescription Deprecated: Use CredentialConfiguration instead. Credential description
	// Deprecated:
	CredentialDescription *string `json:"credential_description,omitempty"`

	// CredentialExpiresAt Deprecated: Use CredentialConfiguration instead. Date when credentials should be consider as expired.
	// Deprecated:
	CredentialExpiresAt *time.Time `json:"credential_expires_at,omitempty"`

	// CredentialName Deprecated: Use CredentialConfiguration instead. Credential name
	// Deprecated:
	CredentialName *string `json:"credential_name,omitempty"`

	// CredentialTemplateId Deprecated: Use CredentialConfiguration instead. Template of the credential to be issued while successfully concluding this interaction. REQUIRED, if the profile is configured to use multiple credential templates.
	// Deprecated:
	CredentialTemplateId *string `json:"credential_template_id,omitempty"`

	// GrantType Issuer can provide custom grant types through this parameter. This grant type has to be used while exchanging an access token for authorization code in later steps.
	GrantType *InitiateOIDC4CIRequestGrantType `json:"grant_type,omitempty"`

	// OpState String value created by the Credential Issuer and opaque to the Wallet that is used to bind the sub-sequent authentication request with the Credential Issuer to a context set up during previous steps. If the client receives a value for this parameter, it MUST include it in the subsequent Authentication Request to the Credential Issuer as the op_state parameter value. MUST NOT be used in Authorization Code flow when pre-authorized_code is present.
	OpState *string `json:"op_state,omitempty"`

	// ResponseType Contains response type that issuer expects VCS to use while performing OIDC authorization request. Defaults to token.
	ResponseType *string `json:"response_type,omitempty"`

	// Scope Contains scopes that issuer expects VCS to use while requesting authorization code for claim data. Defaults to openid.
	Scope *[]string `json:"scope,omitempty"`

	// UserPinRequired Required for Pre-Authorized Code Flow. Boolean value specifying whether the issuer expects presentation of a user PIN along with the Token Request in a pre-authorized code flow.
	UserPinRequired *bool `json:"user_pin_required,omitempty"`

	// WalletInitiatedIssuance Boolean flags indicates whether given transaction is initiated by Wallet.
	WalletInitiatedIssuance *bool `json:"wallet_initiated_issuance,omitempty"`
}

// InitiateOIDC4CIRequestGrantType Issuer can provide custom grant types through this parameter. This grant type has to be used while exchanging an access token for authorization code in later steps.
type InitiateOIDC4CIRequestGrantType string

// InitiateOIDC4CIResponse Model for Initiate OIDC Credential Issuance Response.
type InitiateOIDC4CIResponse struct {
	// OfferCredentialUrl OIDC4CI initiate issuance URL to be used by the Issuer to pass relevant information to the Wallet to initiate issuance flow. Supports both HTTP GET and HTTP Redirect. Issuers may present QR code containing request data for users to scan from their mobile Wallet app.
	OfferCredentialUrl string `json:"offer_credential_url"`

	// TxId To be used by Issuer applications for correlation if needed.
	TxId string `json:"tx_id"`

	// UserPin Pre-authorized flow. Generated OTP pin for issuance.
	UserPin *string `json:"user_pin,omitempty"`
}

// IssueCredentialData Model for issuer credential.
type IssueCredentialData struct {
	// Claims Should be specified if using credential template
	Claims *map[string]interface{} `json:"claims,omitempty"`

	// Credential Credential in jws(string) or jsonld(object) formats.
	Credential *any `json:"credential,omitempty"`

	// CredentialDescription Credential description
	CredentialDescription *string `json:"credential_description,omitempty"`

	// CredentialName Credential name
	CredentialName *string `json:"credential_name,omitempty"`

	// CredentialTemplateId Credential template id
	CredentialTemplateId *string `json:"credential_template_id,omitempty"`

	// Options Options for issuing credential.
	Options *IssueCredentialOptions `json:"options,omitempty"`
}

// IssueCredentialOptions Options for issuing credential.
type IssueCredentialOptions struct {
	// Challenge Chalange is added to the proof.
	Challenge *string `json:"challenge,omitempty"`

	// Created The date of the proof. If omitted system time will be used.
	Created *string `json:"created,omitempty"`

	// CredentialStatus Options for issuing credential.
	CredentialStatus *CredentialStatusOpt `json:"credentialStatus,omitempty"`

	// Domain Domain is added to the proof.
	Domain *string `json:"domain,omitempty"`

	// VerificationMethod The URI of the verificationMethod used for the proof. If omitted first ed25519 public key of DID (Issuer or Profile DID) will be used.
	VerificationMethod *string `json:"verificationMethod,omitempty"`
}

// Logo defines model for Logo.
type Logo struct {
	AltText *string `json:"alt_text,omitempty"`

	// Uri String value that contains a URI where the Wallet can obtain the logo of the Credential Issuer.
	Uri string `json:"uri"`
}

// OAuthParameters Model with key value pairs containing parameters to build OIDC core authorization request (RFC6749) for Issuer OIDC provider to perform wallet user authorization grant.
type OAuthParameters struct {
	ClientId     string   `json:"client_id"`
	ClientSecret string   `json:"client_secret"`
	ResponseType string   `json:"response_type"`
	Scope        []string `json:"scope"`
}

// PrepareBatchCredential Model for Prepare Batch Credential request.
type PrepareBatchCredential struct {
	CredentialRequests []PrepareCredentialBase `json:"credential_requests"`

	// HashedToken Hashed token received from the client.
	HashedToken string `json:"hashed_token"`

	// TxId Transaction ID.
	TxId string `json:"tx_id"`
}

// PrepareClaimDataAuthorizationRequest Model for Prepare Claim Data Authorization Request.
type PrepareClaimDataAuthorizationRequest struct {
	AuthorizationDetails *[]externalRef0.AuthorizationDetails `json:"authorization_details,omitempty"`
	OpState              string                               `json:"op_state"`

	// ResponseType Value MUST be set to "code".
	ResponseType string    `json:"response_type"`
	Scope        *[]string `json:"scope,omitempty"`
}

// PrepareClaimDataAuthorizationResponse Model for Prepare Claim Data Authorization Response.
type PrepareClaimDataAuthorizationResponse struct {
	// AuthorizationEndpoint Issuer's OIDC provider authorization endpoint.
	AuthorizationEndpoint string `json:"authorization_endpoint"`

	// AuthorizationRequest Model with key value pairs containing parameters to build OIDC core authorization request (RFC6749) for Issuer OIDC provider to perform wallet user authorization grant.
	AuthorizationRequest OAuthParameters `json:"authorization_request"`

	// ProfileAuthStateTtl Profile specific Auth state TTL.
	ProfileAuthStateTtl int `json:"profile_auth_state_ttl"`

	// PushedAuthorizationRequestEndpoint Issuer's OIDC provider PAR endpoint.
	PushedAuthorizationRequestEndpoint *string `json:"pushed_authorization_request_endpoint,omitempty"`

	// TxId Transaction ID to correlate upcoming authorization response.
	TxId                string                                `json:"tx_id"`
	WalletInitiatedFlow *externalRef0.WalletInitiatedFlowData `json:"wallet_initiated_flow"`
}

// PrepareCredential defines model for PrepareCredential.
type PrepareCredential struct {
	// AudienceClaim The "aud" claim received from the client.
	AudienceClaim string `json:"audienceClaim"`

	// Did DID to which issued credential has to be bound.
	Did *string `json:"did,omitempty"`

	// Format Format of the credential being issued.
	Format *string `json:"format,omitempty"`

	// HashedToken Hashed token received from the client.
	HashedToken string `json:"hashed_token"`

	// RequestedCredentialResponseEncryption Object containing requested information for encrypting the Credential Response.
	RequestedCredentialResponseEncryption *RequestedCredentialResponseEncryption `json:"requested_credential_response_encryption,omitempty"`

	// TxId Transaction ID.
	TxId string `json:"tx_id"`

	// Types Array of types of the credential being issued.
	Types []string `json:"types"`
}

// PrepareCredentialBase PrepareCredential Base model.
type PrepareCredentialBase struct {
	// AudienceClaim The "aud" claim received from the client.
	AudienceClaim string `json:"audienceClaim"`

	// Did DID to which issued credential has to be bound.
	Did *string `json:"did,omitempty"`

	// Format Format of the credential being issued.
	Format *string `json:"format,omitempty"`

	// RequestedCredentialResponseEncryption Object containing requested information for encrypting the Credential Response.
	RequestedCredentialResponseEncryption *RequestedCredentialResponseEncryption `json:"requested_credential_response_encryption,omitempty"`

	// Types Array of types of the credential being issued.
	Types []string `json:"types"`
}

// PrepareCredentialResult Model for Prepare Credential response.
type PrepareCredentialResult struct {
	// Credential Credential value. According to draft 13 spec.
	Credential any `json:"credential"`

	// Credentials Contains an array of one or more issued Credentials.
	Credentials []externalRef0.CredentialResponseCredentialObject `json:"credentials"`

	// Format Format of issued credential. Internal use only.
	Format string `json:"format"`

	// NotificationId String identifying an issued Credential that the Wallet includes in the acknowledgement request.
	NotificationId string `json:"notification_id"`

	// OidcFormat OIDC credential format. Internal use only.
	OidcFormat string `json:"oidc_format"`

	// Retry Boolean value indicating whether the Wallet should retry the issuance request. Internal Use. Used for deferred issuance.
	Retry bool `json:"retry"`
}

// ProofTypeSupported Object that contains metadata about the proof type that the Credential Issuer supports.
type ProofTypeSupported struct {
	// ProofSigningAlgValuesSupported Array of case sensitive strings that identify the algorithms that the Issuer supports for this proof type.
	ProofSigningAlgValuesSupported []string `json:"proof_signing_alg_values_supported"`
}

// PushAuthorizationDetailsRequest Model for Push Authorization Details request.
type PushAuthorizationDetailsRequest struct {
	AuthorizationDetails []externalRef0.AuthorizationDetails `json:"authorization_details"`
	OpState              string                              `json:"op_state"`
}

// RequestedCredentialResponseEncryption Object containing requested information for encrypting the Credential Response.
type RequestedCredentialResponseEncryption struct {
	// Alg JWE alg algorithm for encrypting the Credential Response.
	Alg string `json:"alg"`

	// Enc JWE enc algorithm for encrypting the Credential Response.
	Enc string `json:"enc"`
}

// SetCredentialRefreshStateRequest defines model for SetCredentialRefreshStateRequest.
type SetCredentialRefreshStateRequest struct {
	// Claims New claims.
	Claims map[string]interface{} `json:"claims"`

	// CredentialDescription Credential description.
	CredentialDescription *string `json:"credential_description,omitempty"`

	// CredentialId Credential ID.
	CredentialId string `json:"credential_id"`

	// CredentialName Credential name.
	CredentialName *string `json:"credential_name,omitempty"`
}

// SetCredentialRefreshStateResult defines model for SetCredentialRefreshStateResult.
type SetCredentialRefreshStateResult struct {
	// TransactionId Transaction ID.
	TransactionId string `json:"transaction_id"`
}

// StoreAuthorizationCodeRequest Model for storing auth code from issuer oauth
type StoreAuthorizationCodeRequest struct {
	Code                string                                `json:"code"`
	OpState             string                                `json:"op_state"`
	WalletInitiatedFlow *externalRef0.WalletInitiatedFlowData `json:"wallet_initiated_flow"`
}

// StoreAuthorizationCodeResponse Response model for storing auth code from issuer oauth
type StoreAuthorizationCodeResponse struct {
	TxId *string `json:"tx_id,omitempty"`
}

// UpdateCredentialStatusRequest UpdateCredentialStatusRequest request struct for updating VC status.
type UpdateCredentialStatusRequest struct {
	CredentialID string `json:"credentialID"`

	// CredentialStatus Credential status.
	CredentialStatus CredentialStatus `json:"credentialStatus"`
	ProfileID        string           `json:"profileID"`
	ProfileVersion   string           `json:"profileVersion"`
}

// ValidatePreAuthorizedCodeRequest Model for validating pre-authorized code and pin.
type ValidatePreAuthorizedCodeRequest struct {
	// ClientAssertion The value MUST contain two JWTs, separated by a "~" character. The first JWT is the client attestation JWT, the second is the client attestation PoP JWT.
	ClientAssertion *string `json:"client_assertion,omitempty"`

	// ClientAssertionType Specifies the method used to authenticate the client application to the authorization server (VCS). The only supported value is "urn:ietf:params:oauth:client-assertion-type:jwt-client-attestation". It indicates that the client must authenticate using OAuth 2.0 Attestation-Based Client Authentication method.
	ClientAssertionType *string `json:"client_assertion_type,omitempty"`

	// ClientId Client ID for VCS OIDC interaction.
	ClientId *string `json:"client_id,omitempty"`

	// PreAuthorizedCode Pre authorized code.
	PreAuthorizedCode string `json:"pre-authorized_code"`

	// UserPin User pin.
	UserPin *string `json:"user_pin,omitempty"`
}

// ValidatePreAuthorizedCodeResponse Model for validating pre-authorized code and pin.
type ValidatePreAuthorizedCodeResponse struct {
	// AuthorizationDetails REQUIRED when authorization_details parameter is used to request issuance of a certain Credential type as defined in Section 5.1.1. It MUST NOT be used otherwise. It is an array of objects, as defined in Section 7 of [RFC9396].
	AuthorizationDetails *[]externalRef0.AuthorizationDetails `json:"authorization_details,omitempty"`

	// OpState Op state.
	OpState string `json:"op_state"`

	// Scopes A list of pre-authorized scopes
	Scopes []string `json:"scopes"`

	// TxId transaction id
	TxId string `json:"tx_id"`
}

// WellKnownOpenIDIssuerConfiguration WellKnownOpenIDIssuerConfiguration represents the OIDC Configuration response for cases when VCS serves as IDP.
type WellKnownOpenIDIssuerConfiguration struct {
	// AuthorizationEndpoint URL of the OP's OAuth 2.0 Authorization Endpoint.
	AuthorizationEndpoint *string `json:"authorization_endpoint,omitempty"`

	// BatchCredentialEndpoint URL of the Credential Issuer's Batch Credential Endpoint. This URL MUST use the https scheme and MAY contain port, path and query parameter components. If omitted, the Credential Issuer does not support the Batch Credential Endpoint.
	BatchCredentialEndpoint *string `json:"batch_credential_endpoint,omitempty"`

	// CredentialConfigurationsSupported An object that describes specifics of the Credential that the Credential Issuer supports issuance of. This object contains a list of name/value pairs, where each name is a unique identifier of the supported credential being described.
	CredentialConfigurationsSupported *map[string]CredentialConfigurationsSupported `json:"credential_configurations_supported,omitempty"`

	// CredentialEndpoint URL of the Credential Issuer's Credential Endpoint. This URL MUST use the https scheme and MAY contain port, path and query parameter components.
	CredentialEndpoint *string `json:"credential_endpoint,omitempty"`

	// CredentialIdentifiersSupported Boolean value specifying whether the Credential Issuer supports returning credential_identifiers parameter in the authorization_details Token Response parameter, with true indicating support. If omitted, the default value is false.
	CredentialIdentifiersSupported *bool `json:"credential_identifiers_supported,omitempty"`

	// CredentialIssuer The Credential Issuer's identifier.
	CredentialIssuer *string `json:"credential_issuer,omitempty"`

	// CredentialResponseEncryption Object containing information about whether the Credential Issuer supports encryption of the Credential and Batch Credential Response on top of TLS
	CredentialResponseEncryption *CredentialResponseEncryptionSupported `json:"credential_response_encryption,omitempty"`

	// DeferredCredentialEndpoint URL of the Credential Issuer's Deferred Credential Endpoint. This URL MUST use the https scheme and MAY contain port, path, and query parameter components. If omitted, the Credential Issuer does not support the Deferred Credential Endpoint.
	DeferredCredentialEndpoint *string `json:"deferred_credential_endpoint,omitempty"`

	// Display An array of objects, where each object contains display properties of a Credential Issuer for a certain language.
	Display *[]CredentialDisplay `json:"display,omitempty"`

	// GrantTypesSupported JSON array containing a list of the OAuth 2.0 Grant Type values that this OP supports.
	GrantTypesSupported *[]string `json:"grant_types_supported,omitempty"`

	// NotificationEndpoint URL of the Credential Issuer's Notification Endpoint. This URL MUST use the https scheme and MAY contain port, path, and query parameter components. If omitted, the Credential Issuer does not support the Notification Endpoint.
	NotificationEndpoint *string `json:"notification_endpoint,omitempty"`

	// PreAuthorizedGrantAnonymousAccessSupported JSON Boolean indicating whether the issuer accepts a Token Request with a Pre-Authorized Code but without a client id. The default is false.
	PreAuthorizedGrantAnonymousAccessSupported *bool `json:"pre-authorized_grant_anonymous_access_supported,omitempty"`

	// RegistrationEndpoint URL of the OP's Dynamic Client Registration Endpoint.
	RegistrationEndpoint *string `json:"registration_endpoint,omitempty"`

	// ResponseTypesSupported JSON array containing a list of the OAuth 2.0 response_type values that this OP supports.
	ResponseTypesSupported *[]string `json:"response_types_supported,omitempty"`

	// ScopesSupported JSON array containing a list of the OAuth 2.0 [RFC6749] scope values that this server supports.
	ScopesSupported *[]string `json:"scopes_supported,omitempty"`

	// SignedMetadata String that is a signed JWT. This JWT contains Credential Issuer metadata parameters as claims.
	SignedMetadata *string `json:"signed_metadata,omitempty"`

	// TokenEndpoint URL of the OP's OAuth 2.0 Token Endpoint.
	TokenEndpoint *string `json:"token_endpoint,omitempty"`

	// TokenEndpointAuthMethodsSupported JSON array containing a list of client authentication methods supported by this token endpoint. Default is "none".
	TokenEndpointAuthMethodsSupported *[]string `json:"token_endpoint_auth_methods_supported,omitempty"`
}

// CredentialIssuanceHistoryParams defines parameters for CredentialIssuanceHistory.
type CredentialIssuanceHistoryParams struct {
	// TxID Issuance transaction ID
	TxID *string `form:"txID,omitempty" json:"txID,omitempty"`

	// CredentialID Credential ID
	CredentialID *string `form:"credentialID,omitempty" json:"credentialID,omitempty"`
}

// PostCredentialsStatusJSONRequestBody defines body for PostCredentialsStatus for application/json ContentType.
type PostCredentialsStatusJSONRequestBody = UpdateCredentialStatusRequest

// ExchangeAuthorizationCodeRequestJSONRequestBody defines body for ExchangeAuthorizationCodeRequest for application/json ContentType.
type ExchangeAuthorizationCodeRequestJSONRequestBody = ExchangeAuthorizationCodeRequest

// PrepareAuthorizationRequestJSONRequestBody defines body for PrepareAuthorizationRequest for application/json ContentType.
type PrepareAuthorizationRequestJSONRequestBody = PrepareClaimDataAuthorizationRequest

// PrepareCredentialJSONRequestBody defines body for PrepareCredential for application/json ContentType.
type PrepareCredentialJSONRequestBody = PrepareCredential

// PrepareBatchCredentialJSONRequestBody defines body for PrepareBatchCredential for application/json ContentType.
type PrepareBatchCredentialJSONRequestBody = PrepareBatchCredential

// PushAuthorizationDetailsJSONRequestBody defines body for PushAuthorizationDetails for application/json ContentType.
type PushAuthorizationDetailsJSONRequestBody = PushAuthorizationDetailsRequest

// StoreAuthorizationCodeRequestJSONRequestBody defines body for StoreAuthorizationCodeRequest for application/json ContentType.
type StoreAuthorizationCodeRequestJSONRequestBody = StoreAuthorizationCodeRequest

// ValidatePreAuthorizedCodeRequestJSONRequestBody defines body for ValidatePreAuthorizedCodeRequest for application/json ContentType.
type ValidatePreAuthorizedCodeRequestJSONRequestBody = ValidatePreAuthorizedCodeRequest

// PostIssueCredentialsJSONRequestBody defines body for PostIssueCredentials for application/json ContentType.
type PostIssueCredentialsJSONRequestBody = IssueCredentialData

// InitiateCredentialComposeIssuanceJSONRequestBody defines body for InitiateCredentialComposeIssuance for application/json ContentType.
type InitiateCredentialComposeIssuanceJSONRequestBody = InitiateOIDC4CIRequest

// InitiateCredentialIssuanceJSONRequestBody defines body for InitiateCredentialIssuance for application/json ContentType.
type InitiateCredentialIssuanceJSONRequestBody = InitiateOIDC4CIRequest

// SetCredentialRefreshStateJSONRequestBody defines body for SetCredentialRefreshState for application/json ContentType.
type SetCredentialRefreshStateJSONRequestBody = SetCredentialRefreshStateRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// PostCredentialsStatusWithBody request with any body
	PostCredentialsStatusWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCredentialsStatus(ctx context.Context, body PostCredentialsStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCredentialsStatus request
	GetCredentialsStatus(ctx context.Context, groupID string, statusID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExchangeAuthorizationCodeRequestWithBody request with any body
	ExchangeAuthorizationCodeRequestWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExchangeAuthorizationCodeRequest(ctx context.Context, body ExchangeAuthorizationCodeRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PrepareAuthorizationRequestWithBody request with any body
	PrepareAuthorizationRequestWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PrepareAuthorizationRequest(ctx context.Context, body PrepareAuthorizationRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PrepareCredentialWithBody request with any body
	PrepareCredentialWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PrepareCredential(ctx context.Context, body PrepareCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PrepareBatchCredentialWithBody request with any body
	PrepareBatchCredentialWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PrepareBatchCredential(ctx context.Context, body PrepareBatchCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PushAuthorizationDetailsWithBody request with any body
	PushAuthorizationDetailsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PushAuthorizationDetails(ctx context.Context, body PushAuthorizationDetailsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StoreAuthorizationCodeRequestWithBody request with any body
	StoreAuthorizationCodeRequestWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreAuthorizationCodeRequest(ctx context.Context, body StoreAuthorizationCodeRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ValidatePreAuthorizedCodeRequestWithBody request with any body
	ValidatePreAuthorizedCodeRequestWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ValidatePreAuthorizedCodeRequest(ctx context.Context, body ValidatePreAuthorizedCodeRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CredentialIssuanceHistory request
	CredentialIssuanceHistory(ctx context.Context, profileID string, params *CredentialIssuanceHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostIssueCredentialsWithBody request with any body
	PostIssueCredentialsWithBody(ctx context.Context, profileID string, profileVersion string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostIssueCredentials(ctx context.Context, profileID string, profileVersion string, body PostIssueCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InitiateCredentialComposeIssuanceWithBody request with any body
	InitiateCredentialComposeIssuanceWithBody(ctx context.Context, profileID string, profileVersion string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InitiateCredentialComposeIssuance(ctx context.Context, profileID string, profileVersion string, body InitiateCredentialComposeIssuanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InitiateCredentialIssuanceWithBody request with any body
	InitiateCredentialIssuanceWithBody(ctx context.Context, profileID string, profileVersion string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InitiateCredentialIssuance(ctx context.Context, profileID string, profileVersion string, body InitiateCredentialIssuanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetCredentialRefreshStateWithBody request with any body
	SetCredentialRefreshStateWithBody(ctx context.Context, profileID string, profileVersion string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetCredentialRefreshState(ctx context.Context, profileID string, profileVersion string, body SetCredentialRefreshStateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OpenidCredentialIssuerConfig request
	OpenidCredentialIssuerConfig(ctx context.Context, profileID string, profileVersion string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OpenidCredentialIssuerConfigV2 request
	OpenidCredentialIssuerConfigV2(ctx context.Context, profileID string, profileVersion string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) PostCredentialsStatusWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCredentialsStatusRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCredentialsStatus(ctx context.Context, body PostCredentialsStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCredentialsStatusRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCredentialsStatus(ctx context.Context, groupID string, statusID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCredentialsStatusRequest(c.Server, groupID, statusID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExchangeAuthorizationCodeRequestWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExchangeAuthorizationCodeRequestRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExchangeAuthorizationCodeRequest(ctx context.Context, body ExchangeAuthorizationCodeRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExchangeAuthorizationCodeRequestRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PrepareAuthorizationRequestWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrepareAuthorizationRequestRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PrepareAuthorizationRequest(ctx context.Context, body PrepareAuthorizationRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrepareAuthorizationRequestRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PrepareCredentialWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrepareCredentialRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PrepareCredential(ctx context.Context, body PrepareCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrepareCredentialRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PrepareBatchCredentialWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrepareBatchCredentialRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PrepareBatchCredential(ctx context.Context, body PrepareBatchCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrepareBatchCredentialRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PushAuthorizationDetailsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPushAuthorizationDetailsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PushAuthorizationDetails(ctx context.Context, body PushAuthorizationDetailsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPushAuthorizationDetailsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreAuthorizationCodeRequestWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreAuthorizationCodeRequestRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreAuthorizationCodeRequest(ctx context.Context, body StoreAuthorizationCodeRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreAuthorizationCodeRequestRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidatePreAuthorizedCodeRequestWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidatePreAuthorizedCodeRequestRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidatePreAuthorizedCodeRequest(ctx context.Context, body ValidatePreAuthorizedCodeRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidatePreAuthorizedCodeRequestRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CredentialIssuanceHistory(ctx context.Context, profileID string, params *CredentialIssuanceHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCredentialIssuanceHistoryRequest(c.Server, profileID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostIssueCredentialsWithBody(ctx context.Context, profileID string, profileVersion string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostIssueCredentialsRequestWithBody(c.Server, profileID, profileVersion, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostIssueCredentials(ctx context.Context, profileID string, profileVersion string, body PostIssueCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostIssueCredentialsRequest(c.Server, profileID, profileVersion, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InitiateCredentialComposeIssuanceWithBody(ctx context.Context, profileID string, profileVersion string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInitiateCredentialComposeIssuanceRequestWithBody(c.Server, profileID, profileVersion, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InitiateCredentialComposeIssuance(ctx context.Context, profileID string, profileVersion string, body InitiateCredentialComposeIssuanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInitiateCredentialComposeIssuanceRequest(c.Server, profileID, profileVersion, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InitiateCredentialIssuanceWithBody(ctx context.Context, profileID string, profileVersion string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInitiateCredentialIssuanceRequestWithBody(c.Server, profileID, profileVersion, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InitiateCredentialIssuance(ctx context.Context, profileID string, profileVersion string, body InitiateCredentialIssuanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInitiateCredentialIssuanceRequest(c.Server, profileID, profileVersion, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetCredentialRefreshStateWithBody(ctx context.Context, profileID string, profileVersion string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetCredentialRefreshStateRequestWithBody(c.Server, profileID, profileVersion, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetCredentialRefreshState(ctx context.Context, profileID string, profileVersion string, body SetCredentialRefreshStateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetCredentialRefreshStateRequest(c.Server, profileID, profileVersion, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OpenidCredentialIssuerConfig(ctx context.Context, profileID string, profileVersion string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOpenidCredentialIssuerConfigRequest(c.Server, profileID, profileVersion)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OpenidCredentialIssuerConfigV2(ctx context.Context, profileID string, profileVersion string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOpenidCredentialIssuerConfigV2Request(c.Server, profileID, profileVersion)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewPostCredentialsStatusRequest calls the generic PostCredentialsStatus builder with application/json body
func NewPostCredentialsStatusRequest(server string, body PostCredentialsStatusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCredentialsStatusRequestWithBody(server, "application/json", bodyReader)
}

// NewPostCredentialsStatusRequestWithBody generates requests for PostCredentialsStatus with any type of body
func NewPostCredentialsStatusRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issuer/credentials/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCredentialsStatusRequest generates requests for GetCredentialsStatus
func NewGetCredentialsStatusRequest(server string, groupID string, statusID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupID", runtime.ParamLocationPath, groupID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "statusID", runtime.ParamLocationPath, statusID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issuer/groups/%s/credentials/status/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExchangeAuthorizationCodeRequestRequest calls the generic ExchangeAuthorizationCodeRequest builder with application/json body
func NewExchangeAuthorizationCodeRequestRequest(server string, body ExchangeAuthorizationCodeRequestJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExchangeAuthorizationCodeRequestRequestWithBody(server, "application/json", bodyReader)
}

// NewExchangeAuthorizationCodeRequestRequestWithBody generates requests for ExchangeAuthorizationCodeRequest with any type of body
func NewExchangeAuthorizationCodeRequestRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issuer/interactions/exchange-authorization-code")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPrepareAuthorizationRequestRequest calls the generic PrepareAuthorizationRequest builder with application/json body
func NewPrepareAuthorizationRequestRequest(server string, body PrepareAuthorizationRequestJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPrepareAuthorizationRequestRequestWithBody(server, "application/json", bodyReader)
}

// NewPrepareAuthorizationRequestRequestWithBody generates requests for PrepareAuthorizationRequest with any type of body
func NewPrepareAuthorizationRequestRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issuer/interactions/prepare-claim-data-authz-request")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPrepareCredentialRequest calls the generic PrepareCredential builder with application/json body
func NewPrepareCredentialRequest(server string, body PrepareCredentialJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPrepareCredentialRequestWithBody(server, "application/json", bodyReader)
}

// NewPrepareCredentialRequestWithBody generates requests for PrepareCredential with any type of body
func NewPrepareCredentialRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issuer/interactions/prepare-credential")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPrepareBatchCredentialRequest calls the generic PrepareBatchCredential builder with application/json body
func NewPrepareBatchCredentialRequest(server string, body PrepareBatchCredentialJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPrepareBatchCredentialRequestWithBody(server, "application/json", bodyReader)
}

// NewPrepareBatchCredentialRequestWithBody generates requests for PrepareBatchCredential with any type of body
func NewPrepareBatchCredentialRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issuer/interactions/prepare-credential-batch")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPushAuthorizationDetailsRequest calls the generic PushAuthorizationDetails builder with application/json body
func NewPushAuthorizationDetailsRequest(server string, body PushAuthorizationDetailsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPushAuthorizationDetailsRequestWithBody(server, "application/json", bodyReader)
}

// NewPushAuthorizationDetailsRequestWithBody generates requests for PushAuthorizationDetails with any type of body
func NewPushAuthorizationDetailsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issuer/interactions/push-authorization-request")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStoreAuthorizationCodeRequestRequest calls the generic StoreAuthorizationCodeRequest builder with application/json body
func NewStoreAuthorizationCodeRequestRequest(server string, body StoreAuthorizationCodeRequestJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStoreAuthorizationCodeRequestRequestWithBody(server, "application/json", bodyReader)
}

// NewStoreAuthorizationCodeRequestRequestWithBody generates requests for StoreAuthorizationCodeRequest with any type of body
func NewStoreAuthorizationCodeRequestRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issuer/interactions/store-authorization-code")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewValidatePreAuthorizedCodeRequestRequest calls the generic ValidatePreAuthorizedCodeRequest builder with application/json body
func NewValidatePreAuthorizedCodeRequestRequest(server string, body ValidatePreAuthorizedCodeRequestJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewValidatePreAuthorizedCodeRequestRequestWithBody(server, "application/json", bodyReader)
}

// NewValidatePreAuthorizedCodeRequestRequestWithBody generates requests for ValidatePreAuthorizedCodeRequest with any type of body
func NewValidatePreAuthorizedCodeRequestRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issuer/interactions/validate-pre-authorized-code")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCredentialIssuanceHistoryRequest generates requests for CredentialIssuanceHistory
func NewCredentialIssuanceHistoryRequest(server string, profileID string, params *CredentialIssuanceHistoryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "profileID", runtime.ParamLocationPath, profileID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issuer/profiles/%s/issued-credentials", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TxID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "txID", runtime.ParamLocationQuery, *params.TxID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CredentialID != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "credentialID", runtime.ParamLocationQuery, *params.CredentialID); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostIssueCredentialsRequest calls the generic PostIssueCredentials builder with application/json body
func NewPostIssueCredentialsRequest(server string, profileID string, profileVersion string, body PostIssueCredentialsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostIssueCredentialsRequestWithBody(server, profileID, profileVersion, "application/json", bodyReader)
}

// NewPostIssueCredentialsRequestWithBody generates requests for PostIssueCredentials with any type of body
func NewPostIssueCredentialsRequestWithBody(server string, profileID string, profileVersion string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "profileID", runtime.ParamLocationPath, profileID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "profileVersion", runtime.ParamLocationPath, profileVersion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issuer/profiles/%s/%s/credentials/issue", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInitiateCredentialComposeIssuanceRequest calls the generic InitiateCredentialComposeIssuance builder with application/json body
func NewInitiateCredentialComposeIssuanceRequest(server string, profileID string, profileVersion string, body InitiateCredentialComposeIssuanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInitiateCredentialComposeIssuanceRequestWithBody(server, profileID, profileVersion, "application/json", bodyReader)
}

// NewInitiateCredentialComposeIssuanceRequestWithBody generates requests for InitiateCredentialComposeIssuance with any type of body
func NewInitiateCredentialComposeIssuanceRequestWithBody(server string, profileID string, profileVersion string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "profileID", runtime.ParamLocationPath, profileID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "profileVersion", runtime.ParamLocationPath, profileVersion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issuer/profiles/%s/%s/interactions/compose-and-initiate-issuance", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInitiateCredentialIssuanceRequest calls the generic InitiateCredentialIssuance builder with application/json body
func NewInitiateCredentialIssuanceRequest(server string, profileID string, profileVersion string, body InitiateCredentialIssuanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInitiateCredentialIssuanceRequestWithBody(server, profileID, profileVersion, "application/json", bodyReader)
}

// NewInitiateCredentialIssuanceRequestWithBody generates requests for InitiateCredentialIssuance with any type of body
func NewInitiateCredentialIssuanceRequestWithBody(server string, profileID string, profileVersion string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "profileID", runtime.ParamLocationPath, profileID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "profileVersion", runtime.ParamLocationPath, profileVersion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issuer/profiles/%s/%s/interactions/initiate-oidc", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSetCredentialRefreshStateRequest calls the generic SetCredentialRefreshState builder with application/json body
func NewSetCredentialRefreshStateRequest(server string, profileID string, profileVersion string, body SetCredentialRefreshStateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetCredentialRefreshStateRequestWithBody(server, profileID, profileVersion, "application/json", bodyReader)
}

// NewSetCredentialRefreshStateRequestWithBody generates requests for SetCredentialRefreshState with any type of body
func NewSetCredentialRefreshStateRequestWithBody(server string, profileID string, profileVersion string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "profileID", runtime.ParamLocationPath, profileID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "profileVersion", runtime.ParamLocationPath, profileVersion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issuer/profiles/%s/%s/interactions/refresh", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOpenidCredentialIssuerConfigRequest generates requests for OpenidCredentialIssuerConfig
func NewOpenidCredentialIssuerConfigRequest(server string, profileID string, profileVersion string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "profileID", runtime.ParamLocationPath, profileID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "profileVersion", runtime.ParamLocationPath, profileVersion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issuer/%s/%s/.well-known/openid-credential-issuer", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOpenidCredentialIssuerConfigV2Request generates requests for OpenidCredentialIssuerConfigV2
func NewOpenidCredentialIssuerConfigV2Request(server string, profileID string, profileVersion string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "profileID", runtime.ParamLocationPath, profileID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "profileVersion", runtime.ParamLocationPath, profileVersion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oidc/idp/%s/%s/.well-known/openid-credential-issuer", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// PostCredentialsStatusWithBodyWithResponse request with any body
	PostCredentialsStatusWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCredentialsStatusResponse, error)

	PostCredentialsStatusWithResponse(ctx context.Context, body PostCredentialsStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCredentialsStatusResponse, error)

	// GetCredentialsStatusWithResponse request
	GetCredentialsStatusWithResponse(ctx context.Context, groupID string, statusID string, reqEditors ...RequestEditorFn) (*GetCredentialsStatusResponse, error)

	// ExchangeAuthorizationCodeRequestWithBodyWithResponse request with any body
	ExchangeAuthorizationCodeRequestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExchangeAuthorizationCodeRequestResponse, error)

	ExchangeAuthorizationCodeRequestWithResponse(ctx context.Context, body ExchangeAuthorizationCodeRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*ExchangeAuthorizationCodeRequestResponse, error)

	// PrepareAuthorizationRequestWithBodyWithResponse request with any body
	PrepareAuthorizationRequestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PrepareAuthorizationRequestResponse, error)

	PrepareAuthorizationRequestWithResponse(ctx context.Context, body PrepareAuthorizationRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*PrepareAuthorizationRequestResponse, error)

	// PrepareCredentialWithBodyWithResponse request with any body
	PrepareCredentialWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PrepareCredentialResponse, error)

	PrepareCredentialWithResponse(ctx context.Context, body PrepareCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*PrepareCredentialResponse, error)

	// PrepareBatchCredentialWithBodyWithResponse request with any body
	PrepareBatchCredentialWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PrepareBatchCredentialResponse, error)

	PrepareBatchCredentialWithResponse(ctx context.Context, body PrepareBatchCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*PrepareBatchCredentialResponse, error)

	// PushAuthorizationDetailsWithBodyWithResponse request with any body
	PushAuthorizationDetailsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PushAuthorizationDetailsResponse, error)

	PushAuthorizationDetailsWithResponse(ctx context.Context, body PushAuthorizationDetailsJSONRequestBody, reqEditors ...RequestEditorFn) (*PushAuthorizationDetailsResponse, error)

	// StoreAuthorizationCodeRequestWithBodyWithResponse request with any body
	StoreAuthorizationCodeRequestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreAuthorizationCodeRequestResponse, error)

	StoreAuthorizationCodeRequestWithResponse(ctx context.Context, body StoreAuthorizationCodeRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreAuthorizationCodeRequestResponse, error)

	// ValidatePreAuthorizedCodeRequestWithBodyWithResponse request with any body
	ValidatePreAuthorizedCodeRequestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidatePreAuthorizedCodeRequestResponse, error)

	ValidatePreAuthorizedCodeRequestWithResponse(ctx context.Context, body ValidatePreAuthorizedCodeRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidatePreAuthorizedCodeRequestResponse, error)

	// CredentialIssuanceHistoryWithResponse request
	CredentialIssuanceHistoryWithResponse(ctx context.Context, profileID string, params *CredentialIssuanceHistoryParams, reqEditors ...RequestEditorFn) (*CredentialIssuanceHistoryResponse, error)

	// PostIssueCredentialsWithBodyWithResponse request with any body
	PostIssueCredentialsWithBodyWithResponse(ctx context.Context, profileID string, profileVersion string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostIssueCredentialsResponse, error)

	PostIssueCredentialsWithResponse(ctx context.Context, profileID string, profileVersion string, body PostIssueCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostIssueCredentialsResponse, error)

	// InitiateCredentialComposeIssuanceWithBodyWithResponse request with any body
	InitiateCredentialComposeIssuanceWithBodyWithResponse(ctx context.Context, profileID string, profileVersion string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InitiateCredentialComposeIssuanceResponse, error)

	InitiateCredentialComposeIssuanceWithResponse(ctx context.Context, profileID string, profileVersion string, body InitiateCredentialComposeIssuanceJSONRequestBody, reqEditors ...RequestEditorFn) (*InitiateCredentialComposeIssuanceResponse, error)

	// InitiateCredentialIssuanceWithBodyWithResponse request with any body
	InitiateCredentialIssuanceWithBodyWithResponse(ctx context.Context, profileID string, profileVersion string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InitiateCredentialIssuanceResponse, error)

	InitiateCredentialIssuanceWithResponse(ctx context.Context, profileID string, profileVersion string, body InitiateCredentialIssuanceJSONRequestBody, reqEditors ...RequestEditorFn) (*InitiateCredentialIssuanceResponse, error)

	// SetCredentialRefreshStateWithBodyWithResponse request with any body
	SetCredentialRefreshStateWithBodyWithResponse(ctx context.Context, profileID string, profileVersion string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetCredentialRefreshStateResponse, error)

	SetCredentialRefreshStateWithResponse(ctx context.Context, profileID string, profileVersion string, body SetCredentialRefreshStateJSONRequestBody, reqEditors ...RequestEditorFn) (*SetCredentialRefreshStateResponse, error)

	// OpenidCredentialIssuerConfigWithResponse request
	OpenidCredentialIssuerConfigWithResponse(ctx context.Context, profileID string, profileVersion string, reqEditors ...RequestEditorFn) (*OpenidCredentialIssuerConfigResponse, error)

	// OpenidCredentialIssuerConfigV2WithResponse request
	OpenidCredentialIssuerConfigV2WithResponse(ctx context.Context, profileID string, profileVersion string, reqEditors ...RequestEditorFn) (*OpenidCredentialIssuerConfigV2Response, error)
}

type PostCredentialsStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
	JSON400      *externalRef0.PublicAPIErrorResponse
	JSON401      *externalRef0.PublicAPIErrorResponse
	JSON403      *externalRef0.PublicAPIErrorResponse
}

// Status returns HTTPResponse.Status
func (r PostCredentialsStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCredentialsStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCredentialsStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r GetCredentialsStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCredentialsStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExchangeAuthorizationCodeRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExchangeAuthorizationCodeResponse
	JSON400      *externalRef0.PrivateAPIErrorResponse
}

// Status returns HTTPResponse.Status
func (r ExchangeAuthorizationCodeRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExchangeAuthorizationCodeRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PrepareAuthorizationRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PrepareClaimDataAuthorizationResponse
	JSON400      *externalRef0.PrivateAPIErrorResponse
}

// Status returns HTTPResponse.Status
func (r PrepareAuthorizationRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PrepareAuthorizationRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PrepareCredentialResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PrepareCredentialResult
	JSON400      *externalRef0.PrivateAPIErrorResponse
}

// Status returns HTTPResponse.Status
func (r PrepareCredentialResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PrepareCredentialResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PrepareBatchCredentialResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PrepareCredentialResult
	JSON400      *externalRef0.PrivateAPIErrorResponse
}

// Status returns HTTPResponse.Status
func (r PrepareBatchCredentialResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PrepareBatchCredentialResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PushAuthorizationDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *externalRef0.PrivateAPIErrorResponse
}

// Status returns HTTPResponse.Status
func (r PushAuthorizationDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PushAuthorizationDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StoreAuthorizationCodeRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StoreAuthorizationCodeResponse
	JSON400      *externalRef0.PrivateAPIErrorResponse
}

// Status returns HTTPResponse.Status
func (r StoreAuthorizationCodeRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StoreAuthorizationCodeRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ValidatePreAuthorizedCodeRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ValidatePreAuthorizedCodeResponse
	JSON400      *externalRef0.PrivateAPIErrorResponse
}

// Status returns HTTPResponse.Status
func (r ValidatePreAuthorizedCodeRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidatePreAuthorizedCodeRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CredentialIssuanceHistoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CredentialIssuanceHistoryData
	JSON400      *externalRef0.PublicAPIErrorResponse
}

// Status returns HTTPResponse.Status
func (r CredentialIssuanceHistoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CredentialIssuanceHistoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostIssueCredentialsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
	JSON400      *externalRef0.PrivateAPIErrorResponse
}

// Status returns HTTPResponse.Status
func (r PostIssueCredentialsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostIssueCredentialsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InitiateCredentialComposeIssuanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InitiateOIDC4CIComposeRequest
	JSON400      *externalRef0.PrivateAPIErrorResponse
}

// Status returns HTTPResponse.Status
func (r InitiateCredentialComposeIssuanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InitiateCredentialComposeIssuanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InitiateCredentialIssuanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InitiateOIDC4CIResponse
	JSON400      *externalRef0.PublicAPIErrorResponse
}

// Status returns HTTPResponse.Status
func (r InitiateCredentialIssuanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InitiateCredentialIssuanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetCredentialRefreshStateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SetCredentialRefreshStateResult
	JSON400      *externalRef0.PublicAPIErrorResponse
}

// Status returns HTTPResponse.Status
func (r SetCredentialRefreshStateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetCredentialRefreshStateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OpenidCredentialIssuerConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WellKnownOpenIDIssuerConfiguration
	JSON400      *externalRef0.PublicAPIErrorResponse
}

// Status returns HTTPResponse.Status
func (r OpenidCredentialIssuerConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OpenidCredentialIssuerConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OpenidCredentialIssuerConfigV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WellKnownOpenIDIssuerConfiguration
	JSON400      *externalRef0.PublicAPIErrorResponse
}

// Status returns HTTPResponse.Status
func (r OpenidCredentialIssuerConfigV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OpenidCredentialIssuerConfigV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// PostCredentialsStatusWithBodyWithResponse request with arbitrary body returning *PostCredentialsStatusResponse
func (c *ClientWithResponses) PostCredentialsStatusWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCredentialsStatusResponse, error) {
	rsp, err := c.PostCredentialsStatusWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCredentialsStatusResponse(rsp)
}

func (c *ClientWithResponses) PostCredentialsStatusWithResponse(ctx context.Context, body PostCredentialsStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCredentialsStatusResponse, error) {
	rsp, err := c.PostCredentialsStatus(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCredentialsStatusResponse(rsp)
}

// GetCredentialsStatusWithResponse request returning *GetCredentialsStatusResponse
func (c *ClientWithResponses) GetCredentialsStatusWithResponse(ctx context.Context, groupID string, statusID string, reqEditors ...RequestEditorFn) (*GetCredentialsStatusResponse, error) {
	rsp, err := c.GetCredentialsStatus(ctx, groupID, statusID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCredentialsStatusResponse(rsp)
}

// ExchangeAuthorizationCodeRequestWithBodyWithResponse request with arbitrary body returning *ExchangeAuthorizationCodeRequestResponse
func (c *ClientWithResponses) ExchangeAuthorizationCodeRequestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExchangeAuthorizationCodeRequestResponse, error) {
	rsp, err := c.ExchangeAuthorizationCodeRequestWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExchangeAuthorizationCodeRequestResponse(rsp)
}

func (c *ClientWithResponses) ExchangeAuthorizationCodeRequestWithResponse(ctx context.Context, body ExchangeAuthorizationCodeRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*ExchangeAuthorizationCodeRequestResponse, error) {
	rsp, err := c.ExchangeAuthorizationCodeRequest(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExchangeAuthorizationCodeRequestResponse(rsp)
}

// PrepareAuthorizationRequestWithBodyWithResponse request with arbitrary body returning *PrepareAuthorizationRequestResponse
func (c *ClientWithResponses) PrepareAuthorizationRequestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PrepareAuthorizationRequestResponse, error) {
	rsp, err := c.PrepareAuthorizationRequestWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrepareAuthorizationRequestResponse(rsp)
}

func (c *ClientWithResponses) PrepareAuthorizationRequestWithResponse(ctx context.Context, body PrepareAuthorizationRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*PrepareAuthorizationRequestResponse, error) {
	rsp, err := c.PrepareAuthorizationRequest(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrepareAuthorizationRequestResponse(rsp)
}

// PrepareCredentialWithBodyWithResponse request with arbitrary body returning *PrepareCredentialResponse
func (c *ClientWithResponses) PrepareCredentialWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PrepareCredentialResponse, error) {
	rsp, err := c.PrepareCredentialWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrepareCredentialResponse(rsp)
}

func (c *ClientWithResponses) PrepareCredentialWithResponse(ctx context.Context, body PrepareCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*PrepareCredentialResponse, error) {
	rsp, err := c.PrepareCredential(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrepareCredentialResponse(rsp)
}

// PrepareBatchCredentialWithBodyWithResponse request with arbitrary body returning *PrepareBatchCredentialResponse
func (c *ClientWithResponses) PrepareBatchCredentialWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PrepareBatchCredentialResponse, error) {
	rsp, err := c.PrepareBatchCredentialWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrepareBatchCredentialResponse(rsp)
}

func (c *ClientWithResponses) PrepareBatchCredentialWithResponse(ctx context.Context, body PrepareBatchCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*PrepareBatchCredentialResponse, error) {
	rsp, err := c.PrepareBatchCredential(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrepareBatchCredentialResponse(rsp)
}

// PushAuthorizationDetailsWithBodyWithResponse request with arbitrary body returning *PushAuthorizationDetailsResponse
func (c *ClientWithResponses) PushAuthorizationDetailsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PushAuthorizationDetailsResponse, error) {
	rsp, err := c.PushAuthorizationDetailsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePushAuthorizationDetailsResponse(rsp)
}

func (c *ClientWithResponses) PushAuthorizationDetailsWithResponse(ctx context.Context, body PushAuthorizationDetailsJSONRequestBody, reqEditors ...RequestEditorFn) (*PushAuthorizationDetailsResponse, error) {
	rsp, err := c.PushAuthorizationDetails(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePushAuthorizationDetailsResponse(rsp)
}

// StoreAuthorizationCodeRequestWithBodyWithResponse request with arbitrary body returning *StoreAuthorizationCodeRequestResponse
func (c *ClientWithResponses) StoreAuthorizationCodeRequestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreAuthorizationCodeRequestResponse, error) {
	rsp, err := c.StoreAuthorizationCodeRequestWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreAuthorizationCodeRequestResponse(rsp)
}

func (c *ClientWithResponses) StoreAuthorizationCodeRequestWithResponse(ctx context.Context, body StoreAuthorizationCodeRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreAuthorizationCodeRequestResponse, error) {
	rsp, err := c.StoreAuthorizationCodeRequest(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreAuthorizationCodeRequestResponse(rsp)
}

// ValidatePreAuthorizedCodeRequestWithBodyWithResponse request with arbitrary body returning *ValidatePreAuthorizedCodeRequestResponse
func (c *ClientWithResponses) ValidatePreAuthorizedCodeRequestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidatePreAuthorizedCodeRequestResponse, error) {
	rsp, err := c.ValidatePreAuthorizedCodeRequestWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidatePreAuthorizedCodeRequestResponse(rsp)
}

func (c *ClientWithResponses) ValidatePreAuthorizedCodeRequestWithResponse(ctx context.Context, body ValidatePreAuthorizedCodeRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidatePreAuthorizedCodeRequestResponse, error) {
	rsp, err := c.ValidatePreAuthorizedCodeRequest(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidatePreAuthorizedCodeRequestResponse(rsp)
}

// CredentialIssuanceHistoryWithResponse request returning *CredentialIssuanceHistoryResponse
func (c *ClientWithResponses) CredentialIssuanceHistoryWithResponse(ctx context.Context, profileID string, params *CredentialIssuanceHistoryParams, reqEditors ...RequestEditorFn) (*CredentialIssuanceHistoryResponse, error) {
	rsp, err := c.CredentialIssuanceHistory(ctx, profileID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCredentialIssuanceHistoryResponse(rsp)
}

// PostIssueCredentialsWithBodyWithResponse request with arbitrary body returning *PostIssueCredentialsResponse
func (c *ClientWithResponses) PostIssueCredentialsWithBodyWithResponse(ctx context.Context, profileID string, profileVersion string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostIssueCredentialsResponse, error) {
	rsp, err := c.PostIssueCredentialsWithBody(ctx, profileID, profileVersion, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostIssueCredentialsResponse(rsp)
}

func (c *ClientWithResponses) PostIssueCredentialsWithResponse(ctx context.Context, profileID string, profileVersion string, body PostIssueCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostIssueCredentialsResponse, error) {
	rsp, err := c.PostIssueCredentials(ctx, profileID, profileVersion, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostIssueCredentialsResponse(rsp)
}

// InitiateCredentialComposeIssuanceWithBodyWithResponse request with arbitrary body returning *InitiateCredentialComposeIssuanceResponse
func (c *ClientWithResponses) InitiateCredentialComposeIssuanceWithBodyWithResponse(ctx context.Context, profileID string, profileVersion string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InitiateCredentialComposeIssuanceResponse, error) {
	rsp, err := c.InitiateCredentialComposeIssuanceWithBody(ctx, profileID, profileVersion, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInitiateCredentialComposeIssuanceResponse(rsp)
}

func (c *ClientWithResponses) InitiateCredentialComposeIssuanceWithResponse(ctx context.Context, profileID string, profileVersion string, body InitiateCredentialComposeIssuanceJSONRequestBody, reqEditors ...RequestEditorFn) (*InitiateCredentialComposeIssuanceResponse, error) {
	rsp, err := c.InitiateCredentialComposeIssuance(ctx, profileID, profileVersion, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInitiateCredentialComposeIssuanceResponse(rsp)
}

// InitiateCredentialIssuanceWithBodyWithResponse request with arbitrary body returning *InitiateCredentialIssuanceResponse
func (c *ClientWithResponses) InitiateCredentialIssuanceWithBodyWithResponse(ctx context.Context, profileID string, profileVersion string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InitiateCredentialIssuanceResponse, error) {
	rsp, err := c.InitiateCredentialIssuanceWithBody(ctx, profileID, profileVersion, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInitiateCredentialIssuanceResponse(rsp)
}

func (c *ClientWithResponses) InitiateCredentialIssuanceWithResponse(ctx context.Context, profileID string, profileVersion string, body InitiateCredentialIssuanceJSONRequestBody, reqEditors ...RequestEditorFn) (*InitiateCredentialIssuanceResponse, error) {
	rsp, err := c.InitiateCredentialIssuance(ctx, profileID, profileVersion, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInitiateCredentialIssuanceResponse(rsp)
}

// SetCredentialRefreshStateWithBodyWithResponse request with arbitrary body returning *SetCredentialRefreshStateResponse
func (c *ClientWithResponses) SetCredentialRefreshStateWithBodyWithResponse(ctx context.Context, profileID string, profileVersion string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetCredentialRefreshStateResponse, error) {
	rsp, err := c.SetCredentialRefreshStateWithBody(ctx, profileID, profileVersion, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetCredentialRefreshStateResponse(rsp)
}

func (c *ClientWithResponses) SetCredentialRefreshStateWithResponse(ctx context.Context, profileID string, profileVersion string, body SetCredentialRefreshStateJSONRequestBody, reqEditors ...RequestEditorFn) (*SetCredentialRefreshStateResponse, error) {
	rsp, err := c.SetCredentialRefreshState(ctx, profileID, profileVersion, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetCredentialRefreshStateResponse(rsp)
}

// OpenidCredentialIssuerConfigWithResponse request returning *OpenidCredentialIssuerConfigResponse
func (c *ClientWithResponses) OpenidCredentialIssuerConfigWithResponse(ctx context.Context, profileID string, profileVersion string, reqEditors ...RequestEditorFn) (*OpenidCredentialIssuerConfigResponse, error) {
	rsp, err := c.OpenidCredentialIssuerConfig(ctx, profileID, profileVersion, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOpenidCredentialIssuerConfigResponse(rsp)
}

// OpenidCredentialIssuerConfigV2WithResponse request returning *OpenidCredentialIssuerConfigV2Response
func (c *ClientWithResponses) OpenidCredentialIssuerConfigV2WithResponse(ctx context.Context, profileID string, profileVersion string, reqEditors ...RequestEditorFn) (*OpenidCredentialIssuerConfigV2Response, error) {
	rsp, err := c.OpenidCredentialIssuerConfigV2(ctx, profileID, profileVersion, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOpenidCredentialIssuerConfigV2Response(rsp)
}

// ParsePostCredentialsStatusResponse parses an HTTP response from a PostCredentialsStatusWithResponse call
func ParsePostCredentialsStatusResponse(rsp *http.Response) (*PostCredentialsStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCredentialsStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.PublicAPIErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.PublicAPIErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest externalRef0.PublicAPIErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetCredentialsStatusResponse parses an HTTP response from a GetCredentialsStatusWithResponse call
func ParseGetCredentialsStatusResponse(rsp *http.Response) (*GetCredentialsStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCredentialsStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseExchangeAuthorizationCodeRequestResponse parses an HTTP response from a ExchangeAuthorizationCodeRequestWithResponse call
func ParseExchangeAuthorizationCodeRequestResponse(rsp *http.Response) (*ExchangeAuthorizationCodeRequestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExchangeAuthorizationCodeRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExchangeAuthorizationCodeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.PrivateAPIErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePrepareAuthorizationRequestResponse parses an HTTP response from a PrepareAuthorizationRequestWithResponse call
func ParsePrepareAuthorizationRequestResponse(rsp *http.Response) (*PrepareAuthorizationRequestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PrepareAuthorizationRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PrepareClaimDataAuthorizationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.PrivateAPIErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePrepareCredentialResponse parses an HTTP response from a PrepareCredentialWithResponse call
func ParsePrepareCredentialResponse(rsp *http.Response) (*PrepareCredentialResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PrepareCredentialResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PrepareCredentialResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.PrivateAPIErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePrepareBatchCredentialResponse parses an HTTP response from a PrepareBatchCredentialWithResponse call
func ParsePrepareBatchCredentialResponse(rsp *http.Response) (*PrepareBatchCredentialResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PrepareBatchCredentialResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PrepareCredentialResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.PrivateAPIErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePushAuthorizationDetailsResponse parses an HTTP response from a PushAuthorizationDetailsWithResponse call
func ParsePushAuthorizationDetailsResponse(rsp *http.Response) (*PushAuthorizationDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PushAuthorizationDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.PrivateAPIErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseStoreAuthorizationCodeRequestResponse parses an HTTP response from a StoreAuthorizationCodeRequestWithResponse call
func ParseStoreAuthorizationCodeRequestResponse(rsp *http.Response) (*StoreAuthorizationCodeRequestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StoreAuthorizationCodeRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StoreAuthorizationCodeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.PrivateAPIErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseValidatePreAuthorizedCodeRequestResponse parses an HTTP response from a ValidatePreAuthorizedCodeRequestWithResponse call
func ParseValidatePreAuthorizedCodeRequestResponse(rsp *http.Response) (*ValidatePreAuthorizedCodeRequestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ValidatePreAuthorizedCodeRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ValidatePreAuthorizedCodeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.PrivateAPIErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCredentialIssuanceHistoryResponse parses an HTTP response from a CredentialIssuanceHistoryWithResponse call
func ParseCredentialIssuanceHistoryResponse(rsp *http.Response) (*CredentialIssuanceHistoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CredentialIssuanceHistoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CredentialIssuanceHistoryData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.PublicAPIErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostIssueCredentialsResponse parses an HTTP response from a PostIssueCredentialsWithResponse call
func ParsePostIssueCredentialsResponse(rsp *http.Response) (*PostIssueCredentialsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostIssueCredentialsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.PrivateAPIErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseInitiateCredentialComposeIssuanceResponse parses an HTTP response from a InitiateCredentialComposeIssuanceWithResponse call
func ParseInitiateCredentialComposeIssuanceResponse(rsp *http.Response) (*InitiateCredentialComposeIssuanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InitiateCredentialComposeIssuanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InitiateOIDC4CIComposeRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.PrivateAPIErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseInitiateCredentialIssuanceResponse parses an HTTP response from a InitiateCredentialIssuanceWithResponse call
func ParseInitiateCredentialIssuanceResponse(rsp *http.Response) (*InitiateCredentialIssuanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InitiateCredentialIssuanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InitiateOIDC4CIResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.PublicAPIErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseSetCredentialRefreshStateResponse parses an HTTP response from a SetCredentialRefreshStateWithResponse call
func ParseSetCredentialRefreshStateResponse(rsp *http.Response) (*SetCredentialRefreshStateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetCredentialRefreshStateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SetCredentialRefreshStateResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.PublicAPIErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseOpenidCredentialIssuerConfigResponse parses an HTTP response from a OpenidCredentialIssuerConfigWithResponse call
func ParseOpenidCredentialIssuerConfigResponse(rsp *http.Response) (*OpenidCredentialIssuerConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OpenidCredentialIssuerConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WellKnownOpenIDIssuerConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.PublicAPIErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseOpenidCredentialIssuerConfigV2Response parses an HTTP response from a OpenidCredentialIssuerConfigV2WithResponse call
func ParseOpenidCredentialIssuerConfigV2Response(rsp *http.Response) (*OpenidCredentialIssuerConfigV2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OpenidCredentialIssuerConfigV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WellKnownOpenIDIssuerConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest externalRef0.PublicAPIErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Updates credential status.
	// (POST /issuer/credentials/status)
	PostCredentialsStatus(ctx echo.Context) error
	// Retrieves the credential status.
	// (GET /issuer/groups/{groupID}/credentials/status/{statusID})
	GetCredentialsStatus(ctx echo.Context, groupID string, statusID string) error
	// Exchange authorization code from issuer oauth provider
	// (POST /issuer/interactions/exchange-authorization-code)
	ExchangeAuthorizationCodeRequest(ctx echo.Context) error
	// Prepare Claim Data Authorization Request
	// (POST /issuer/interactions/prepare-claim-data-authz-request)
	PrepareAuthorizationRequest(ctx echo.Context) error
	// Prepare Credential
	// (POST /issuer/interactions/prepare-credential)
	PrepareCredential(ctx echo.Context) error
	// Prepare Batch Credential
	// (POST /issuer/interactions/prepare-credential-batch)
	PrepareBatchCredential(ctx echo.Context) error
	// Push Authorization Details
	// (POST /issuer/interactions/push-authorization-request)
	PushAuthorizationDetails(ctx echo.Context) error
	// Stores authorization code from issuer oauth provider
	// (POST /issuer/interactions/store-authorization-code)
	StoreAuthorizationCodeRequest(ctx echo.Context) error
	// Validates pre-authorized code and user pin
	// (POST /issuer/interactions/validate-pre-authorized-code)
	ValidatePreAuthorizedCodeRequest(ctx echo.Context) error
	// Request Credential Issuance history.
	// (GET /issuer/profiles/{profileID}/issued-credentials)
	CredentialIssuanceHistory(ctx echo.Context, profileID string, params CredentialIssuanceHistoryParams) error
	// Issue credential
	// (POST /issuer/profiles/{profileID}/{profileVersion}/credentials/issue)
	PostIssueCredentials(ctx echo.Context, profileID string, profileVersion string) error
	// Initiate OIDC Compose Credential Issuance
	// (POST /issuer/profiles/{profileID}/{profileVersion}/interactions/compose-and-initiate-issuance)
	InitiateCredentialComposeIssuance(ctx echo.Context, profileID string, profileVersion string) error
	// Initiate OIDC Credential Issuance
	// (POST /issuer/profiles/{profileID}/{profileVersion}/interactions/initiate-oidc)
	InitiateCredentialIssuance(ctx echo.Context, profileID string, profileVersion string) error
	// Set Credential Refresh State
	// (POST /issuer/profiles/{profileID}/{profileVersion}/interactions/refresh)
	SetCredentialRefreshState(ctx echo.Context, profileID string, profileVersion string) error
	// Request VCS IDP OIDC Configuration.
	// (GET /issuer/{profileID}/{profileVersion}/.well-known/openid-credential-issuer)
	OpenidCredentialIssuerConfig(ctx echo.Context, profileID string, profileVersion string) error
	// Request VCS IDP OIDC Configuration.
	// (GET /oidc/idp/{profileID}/{profileVersion}/.well-known/openid-credential-issuer)
	OpenidCredentialIssuerConfigV2(ctx echo.Context, profileID string, profileVersion string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// PostCredentialsStatus converts echo context to params.
func (w *ServerInterfaceWrapper) PostCredentialsStatus(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostCredentialsStatus(ctx)
	return err
}

// GetCredentialsStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetCredentialsStatus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "groupID" -------------
	var groupID string

	err = runtime.BindStyledParameterWithOptions("simple", "groupID", ctx.Param("groupID"), &groupID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter groupID: %s", err))
	}

	// ------------- Path parameter "statusID" -------------
	var statusID string

	err = runtime.BindStyledParameterWithOptions("simple", "statusID", ctx.Param("statusID"), &statusID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter statusID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCredentialsStatus(ctx, groupID, statusID)
	return err
}

// ExchangeAuthorizationCodeRequest converts echo context to params.
func (w *ServerInterfaceWrapper) ExchangeAuthorizationCodeRequest(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ExchangeAuthorizationCodeRequest(ctx)
	return err
}

// PrepareAuthorizationRequest converts echo context to params.
func (w *ServerInterfaceWrapper) PrepareAuthorizationRequest(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PrepareAuthorizationRequest(ctx)
	return err
}

// PrepareCredential converts echo context to params.
func (w *ServerInterfaceWrapper) PrepareCredential(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PrepareCredential(ctx)
	return err
}

// PrepareBatchCredential converts echo context to params.
func (w *ServerInterfaceWrapper) PrepareBatchCredential(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PrepareBatchCredential(ctx)
	return err
}

// PushAuthorizationDetails converts echo context to params.
func (w *ServerInterfaceWrapper) PushAuthorizationDetails(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PushAuthorizationDetails(ctx)
	return err
}

// StoreAuthorizationCodeRequest converts echo context to params.
func (w *ServerInterfaceWrapper) StoreAuthorizationCodeRequest(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.StoreAuthorizationCodeRequest(ctx)
	return err
}

// ValidatePreAuthorizedCodeRequest converts echo context to params.
func (w *ServerInterfaceWrapper) ValidatePreAuthorizedCodeRequest(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ValidatePreAuthorizedCodeRequest(ctx)
	return err
}

// CredentialIssuanceHistory converts echo context to params.
func (w *ServerInterfaceWrapper) CredentialIssuanceHistory(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "profileID" -------------
	var profileID string

	err = runtime.BindStyledParameterWithOptions("simple", "profileID", ctx.Param("profileID"), &profileID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter profileID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params CredentialIssuanceHistoryParams
	// ------------- Optional query parameter "txID" -------------

	err = runtime.BindQueryParameter("form", true, false, "txID", ctx.QueryParams(), &params.TxID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txID: %s", err))
	}

	// ------------- Optional query parameter "credentialID" -------------

	err = runtime.BindQueryParameter("form", true, false, "credentialID", ctx.QueryParams(), &params.CredentialID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter credentialID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CredentialIssuanceHistory(ctx, profileID, params)
	return err
}

// PostIssueCredentials converts echo context to params.
func (w *ServerInterfaceWrapper) PostIssueCredentials(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "profileID" -------------
	var profileID string

	err = runtime.BindStyledParameterWithOptions("simple", "profileID", ctx.Param("profileID"), &profileID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter profileID: %s", err))
	}

	// ------------- Path parameter "profileVersion" -------------
	var profileVersion string

	err = runtime.BindStyledParameterWithOptions("simple", "profileVersion", ctx.Param("profileVersion"), &profileVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter profileVersion: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostIssueCredentials(ctx, profileID, profileVersion)
	return err
}

// InitiateCredentialComposeIssuance converts echo context to params.
func (w *ServerInterfaceWrapper) InitiateCredentialComposeIssuance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "profileID" -------------
	var profileID string

	err = runtime.BindStyledParameterWithOptions("simple", "profileID", ctx.Param("profileID"), &profileID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter profileID: %s", err))
	}

	// ------------- Path parameter "profileVersion" -------------
	var profileVersion string

	err = runtime.BindStyledParameterWithOptions("simple", "profileVersion", ctx.Param("profileVersion"), &profileVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter profileVersion: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InitiateCredentialComposeIssuance(ctx, profileID, profileVersion)
	return err
}

// InitiateCredentialIssuance converts echo context to params.
func (w *ServerInterfaceWrapper) InitiateCredentialIssuance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "profileID" -------------
	var profileID string

	err = runtime.BindStyledParameterWithOptions("simple", "profileID", ctx.Param("profileID"), &profileID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter profileID: %s", err))
	}

	// ------------- Path parameter "profileVersion" -------------
	var profileVersion string

	err = runtime.BindStyledParameterWithOptions("simple", "profileVersion", ctx.Param("profileVersion"), &profileVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter profileVersion: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InitiateCredentialIssuance(ctx, profileID, profileVersion)
	return err
}

// SetCredentialRefreshState converts echo context to params.
func (w *ServerInterfaceWrapper) SetCredentialRefreshState(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "profileID" -------------
	var profileID string

	err = runtime.BindStyledParameterWithOptions("simple", "profileID", ctx.Param("profileID"), &profileID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter profileID: %s", err))
	}

	// ------------- Path parameter "profileVersion" -------------
	var profileVersion string

	err = runtime.BindStyledParameterWithOptions("simple", "profileVersion", ctx.Param("profileVersion"), &profileVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter profileVersion: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SetCredentialRefreshState(ctx, profileID, profileVersion)
	return err
}

// OpenidCredentialIssuerConfig converts echo context to params.
func (w *ServerInterfaceWrapper) OpenidCredentialIssuerConfig(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "profileID" -------------
	var profileID string

	err = runtime.BindStyledParameterWithOptions("simple", "profileID", ctx.Param("profileID"), &profileID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter profileID: %s", err))
	}

	// ------------- Path parameter "profileVersion" -------------
	var profileVersion string

	err = runtime.BindStyledParameterWithOptions("simple", "profileVersion", ctx.Param("profileVersion"), &profileVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter profileVersion: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OpenidCredentialIssuerConfig(ctx, profileID, profileVersion)
	return err
}

// OpenidCredentialIssuerConfigV2 converts echo context to params.
func (w *ServerInterfaceWrapper) OpenidCredentialIssuerConfigV2(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "profileID" -------------
	var profileID string

	err = runtime.BindStyledParameterWithOptions("simple", "profileID", ctx.Param("profileID"), &profileID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter profileID: %s", err))
	}

	// ------------- Path parameter "profileVersion" -------------
	var profileVersion string

	err = runtime.BindStyledParameterWithOptions("simple", "profileVersion", ctx.Param("profileVersion"), &profileVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter profileVersion: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OpenidCredentialIssuerConfigV2(ctx, profileID, profileVersion)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/issuer/credentials/status", wrapper.PostCredentialsStatus)
	router.GET(baseURL+"/issuer/groups/:groupID/credentials/status/:statusID", wrapper.GetCredentialsStatus)
	router.POST(baseURL+"/issuer/interactions/exchange-authorization-code", wrapper.ExchangeAuthorizationCodeRequest)
	router.POST(baseURL+"/issuer/interactions/prepare-claim-data-authz-request", wrapper.PrepareAuthorizationRequest)
	router.POST(baseURL+"/issuer/interactions/prepare-credential", wrapper.PrepareCredential)
	router.POST(baseURL+"/issuer/interactions/prepare-credential-batch", wrapper.PrepareBatchCredential)
	router.POST(baseURL+"/issuer/interactions/push-authorization-request", wrapper.PushAuthorizationDetails)
	router.POST(baseURL+"/issuer/interactions/store-authorization-code", wrapper.StoreAuthorizationCodeRequest)
	router.POST(baseURL+"/issuer/interactions/validate-pre-authorized-code", wrapper.ValidatePreAuthorizedCodeRequest)
	router.GET(baseURL+"/issuer/profiles/:profileID/issued-credentials", wrapper.CredentialIssuanceHistory)
	router.POST(baseURL+"/issuer/profiles/:profileID/:profileVersion/credentials/issue", wrapper.PostIssueCredentials)
	router.POST(baseURL+"/issuer/profiles/:profileID/:profileVersion/interactions/compose-and-initiate-issuance", wrapper.InitiateCredentialComposeIssuance)
	router.POST(baseURL+"/issuer/profiles/:profileID/:profileVersion/interactions/initiate-oidc", wrapper.InitiateCredentialIssuance)
	router.POST(baseURL+"/issuer/profiles/:profileID/:profileVersion/interactions/refresh", wrapper.SetCredentialRefreshState)
	router.GET(baseURL+"/issuer/:profileID/:profileVersion/.well-known/openid-credential-issuer", wrapper.OpenidCredentialIssuerConfig)
	router.GET(baseURL+"/oidc/idp/:profileID/:profileVersion/.well-known/openid-credential-issuer", wrapper.OpenidCredentialIssuerConfigV2)

}
