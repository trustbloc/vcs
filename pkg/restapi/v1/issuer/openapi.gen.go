// Package issuer provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package issuer

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/labstack/echo/v4"
	externalRef0 "github.com/trustbloc/vcs/pkg/restapi/v1/common"
)

// An object that describes specifics of the Credential that the Credential Issuer supports issuance of.
type CredentialConfigurationsSupported struct {
	// For mso_mdoc and vc+sd-jwt vc only. Object containing a list of name/value pairs, where each name identifies a claim about the subject offered in the Credential. The value can be another such object (nested data structures), or an array of such objects.
	Claims *map[string]interface{} `json:"claims,omitempty"`

	// Object containing the detailed description of the credential type.
	CredentialDefinition *externalRef0.CredentialDefinition `json:"credential_definition,omitempty"`

	// Array of case sensitive strings that identify how the Credential is bound to the identifier of the End-User who possesses the Credential.
	CryptographicBindingMethodsSupported *[]string `json:"cryptographic_binding_methods_supported,omitempty"`

	// Array of case sensitive strings that identify the cryptographic suites that are supported for the cryptographic_binding_methods_supported.
	CryptographicSuitesSupported *[]string `json:"cryptographic_suites_supported,omitempty"`

	// An array of objects, where each object contains the display properties of the supported credential for a certain language.
	Display *[]CredentialDisplay `json:"display,omitempty"`

	// For mso_mdoc vc only. String identifying the Credential type, as defined in [ISO.18013-5].
	Doctype *string `json:"doctype,omitempty"`

	// A JSON string identifying the format of this credential, i.e., jwt_vc_json or ldp_vc. Depending on the format value, the object contains further elements defining the type and (optionally) particular claims the credential MAY contain and information about how to display the credential.
	Format string `json:"format"`

	// Array of the claim name values that lists them in the order they should be displayed by the Wallet.
	Order *[]string `json:"order,omitempty"`

	// A JSON array of case sensitive strings, each representing proof_type that the Credential Issuer supports. If omitted, the default value is jwt.
	ProofTypes *[]string `json:"proof_types,omitempty"`

	// A JSON string identifying the scope value that this Credential Issuer supports for this particular credential.
	Scope *string `json:"scope,omitempty"`

	// For vc+sd-jwt vc only. String designating the type of a Credential, as defined in https://datatracker.ietf.org/doc/html/draft-ietf-oauth-sd-jwt-vc-01
	Vct *string `json:"vct,omitempty"`
}

// CredentialDisplay defines model for CredentialDisplay.
type CredentialDisplay struct {
	BackgroundColor *string `json:"background_color,omitempty"`
	Locale          *string `json:"locale,omitempty"`
	Logo            *Logo   `json:"logo,omitempty"`
	Name            *string `json:"name,omitempty"`
	TextColor       *string `json:"text_color,omitempty"`
	Url             *string `json:"url,omitempty"`
}

// CredentialIssuanceHistoryData represents the credential issuance history array element.
type CredentialIssuanceHistoryData struct {
	// Credential ID.
	CredentialId string `json:"credential_id"`

	// JSON array of credential types.
	CredentialTypes []string `json:"credential_types"`

	// Expiration Date.
	ExpirationDate *string `json:"expiration_date,omitempty"`

	// Issuance Date.
	IssuanceDate *string `json:"issuance_date,omitempty"`

	// Issuer identifier.
	Issuer string `json:"issuer"`

	// Transaction ID.
	TransactionId *string `json:"transaction_id,omitempty"`
}

// Object containing information about whether the Credential Issuer supports encryption of the Credential and Batch Credential Response on top of TLS
type CredentialResponseEncryptionSupported struct {
	// Array containing a list of the JWE [RFC7516] encryption algorithms (alg values) [RFC7518] supported by the Credential and Batch Credential Endpoint to encode the Credential or Batch Credential Response in a JWT [RFC7519].
	AlgValuesSupported []string `json:"alg_values_supported"`

	// Array containing a list of the JWE [RFC7516] encryption algorithms (enc values) [RFC7518] supported by the Credential and Batch Credential Endpoint to encode the Credential or Batch Credential Response in a JWT [RFC7519].
	EncValuesSupported []string `json:"enc_values_supported"`

	// Boolean value specifying whether the Credential Issuer requires the additional encryption on top of TLS for the Credential Response. If the value is true, the Credential Issuer requires encryption for every Credential Response and therefore the Wallet MUST provide encryption keys in the Credential Request. If the value is false, the Wallet MAY chose whether it provides encryption keys or not.
	EncryptionRequired bool `json:"encryption_required"`
}

// Credential status.
type CredentialStatus struct {
	Status string `json:"status"`
	Type   string `json:"type"`
}

// Options for issuing credential.
type CredentialStatusOpt struct {
	Type string `json:"type"`
}

// Model for exchanging auth code from issuer oauth
type ExchangeAuthorizationCodeRequest struct {
	// The value MUST contain two JWTs, separated by a "~" character. The first JWT is the client attestation JWT, the second is the client attestation PoP JWT.
	ClientAssertion *string `json:"client_assertion,omitempty"`

	// Specifies the method used to authenticate the client application to the authorization server (VCS). The only supported value is "urn:ietf:params:oauth:client-assertion-type:jwt-client-attestation". It indicates that the client must authenticate using OAuth 2.0 Attestation-Based Client Authentication method.
	ClientAssertionType *string `json:"client_assertion_type,omitempty"`

	// Client ID for VCS OIDC interaction.
	ClientId *string `json:"client_id,omitempty"`
	OpState  string  `json:"op_state"`
}

// Response model for exchanging auth code from issuer oauth
type ExchangeAuthorizationCodeResponse struct {
	AuthorizationDetails *[]externalRef0.AuthorizationDetails `json:"authorization_details,omitempty"`
	TxId                 string                               `json:"tx_id"`
}

// Model for Initiate OIDC Credential Issuance Request.
type InitiateOIDC4CIRequest struct {
	// Customizes what kind of access Issuer wants to give to VCS.
	AuthorizationDetails *string `json:"authorization_details,omitempty"`

	// Required for Pre-Authorized Code Flow. VCS OIDC Service acts as OP for wallet applications
	ClaimData *map[string]interface{} `json:"claim_data,omitempty"`

	// Claim endpoint of the Issuer from where credential claim data has to be requested after successfully acquiring access tokens.
	ClaimEndpoint *string `json:"claim_endpoint,omitempty"`

	// URL of the issuance initiation endpoint of a Wallet. Takes precedence over client_wellknown request parameter. If both client_initiate_issuance_url and client_wellknown are not provided then response initiate issuance URL will contain custom initiate issuance URL in format openid-initiate-issuance://.
	ClientInitiateIssuanceUrl *string `json:"client_initiate_issuance_url,omitempty"`

	// String containing wallet/holder application OIDC client wellknown configuration URL.
	ClientWellknown *string `json:"client_wellknown,omitempty"`

	// Credential description
	CredentialDescription *string `json:"credential_description,omitempty"`

	// Date when credentials should be consider as expired
	CredentialExpiresAt *time.Time `json:"credential_expires_at,omitempty"`

	// Credential name
	CredentialName *string `json:"credential_name,omitempty"`

	// Template of the credential to be issued while successfully concluding this interaction. REQUIRED, if the profile is configured to use multiple credential templates.
	CredentialTemplateId *string `json:"credential_template_id,omitempty"`

	// Issuer can provide custom grant types through this parameter. This grant type has to be used while exchanging an access token for authorization code in later steps. If not provided then default to authorization_code.
	GrantType *string `json:"grant_type,omitempty"`

	// String value created by the Credential Issuer and opaque to the Wallet that is used to bind the sub-sequent authentication request with the Credential Issuer to a context set up during previous steps. If the client receives a value for this parameter, it MUST include it in the subsequent Authentication Request to the Credential Issuer as the op_state parameter value. MUST NOT be used in Authorization Code flow when pre-authorized_code is present.
	OpState *string `json:"op_state,omitempty"`

	// Contains response type that issuer expects VCS to use while performing OIDC authorization request. Defaults to token.
	ResponseType *string `json:"response_type,omitempty"`

	// Contains scopes that issuer expects VCS to use while requesting authorization code for claim data. Defaults to openid.
	Scope *[]string `json:"scope,omitempty"`

	// Required for Pre-Authorized Code Flow. Boolean value specifying whether the issuer expects presentation of a user PIN along with the Token Request in a pre-authorized code flow.
	UserPinRequired *bool `json:"user_pin_required,omitempty"`

	// Boolean flags indicates whether given transaction is initiated by Wallet.
	WalletInitiatedIssuance *bool `json:"wallet_initiated_issuance,omitempty"`
}

// Model for Initiate OIDC Credential Issuance Response.
type InitiateOIDC4CIResponse struct {
	// OIDC4CI initiate issuance URL to be used by the Issuer to pass relevant information to the Wallet to initiate issuance flow. Supports both HTTP GET and HTTP Redirect. Issuers may present QR code containing request data for users to scan from their mobile Wallet app.
	OfferCredentialUrl string `json:"offer_credential_url"`

	// To be used by Issuer applications for correlation if needed.
	TxId string `json:"tx_id"`

	// Pre-authorized flow. Generated OTP pin for issuance.
	UserPin *string `json:"user_pin,omitempty"`
}

// Model for issuer credential.
type IssueCredentialData struct {
	// Should be specified if using credential template
	Claims *map[string]interface{} `json:"claims,omitempty"`

	// Credential in jws(string) or jsonld(object) formats.
	Credential *interface{} `json:"credential,omitempty"`

	// Credential description
	CredentialDescription *string `json:"credential_description,omitempty"`

	// Credential name
	CredentialName *string `json:"credential_name,omitempty"`

	// Credential template id
	CredentialTemplateId *string `json:"credential_template_id,omitempty"`

	// Options for issuing credential.
	Options *IssueCredentialOptions `json:"options,omitempty"`
}

// Options for issuing credential.
type IssueCredentialOptions struct {
	// Chalange is added to the proof.
	Challenge *string `json:"challenge,omitempty"`

	// The date of the proof. If omitted system time will be used.
	Created *string `json:"created,omitempty"`

	// Options for issuing credential.
	CredentialStatus *CredentialStatusOpt `json:"credentialStatus,omitempty"`

	// Domain is added to the proof.
	Domain *string `json:"domain,omitempty"`

	// The URI of the verificationMethod used for the proof. If omitted first ed25519 public key of DID (Issuer or Profile DID) will be used.
	VerificationMethod *string `json:"verificationMethod,omitempty"`
}

// Logo defines model for Logo.
type Logo struct {
	AltText *string `json:"alt_text,omitempty"`

	// String value that contains a URI where the Wallet can obtain the logo of the Credential Issuer.
	Uri string `json:"uri"`
}

// Model with key value pairs containing parameters to build OIDC core authorization request (RFC6749) for Issuer OIDC provider to perform wallet user authorization grant.
type OAuthParameters struct {
	ClientId     string   `json:"client_id"`
	ClientSecret string   `json:"client_secret"`
	ResponseType string   `json:"response_type"`
	Scope        []string `json:"scope"`
}

// Model for Prepare Claim Data Authorization Request.
type PrepareClaimDataAuthorizationRequest struct {
	AuthorizationDetails *[]externalRef0.AuthorizationDetails `json:"authorization_details,omitempty"`
	OpState              string                               `json:"op_state"`

	// Value MUST be set to "code".
	ResponseType string    `json:"response_type"`
	Scope        *[]string `json:"scope,omitempty"`
}

// Model for Prepare Claim Data Authorization Response.
type PrepareClaimDataAuthorizationResponse struct {
	// Issuer's OIDC provider authorization endpoint.
	AuthorizationEndpoint string `json:"authorization_endpoint"`

	// Model with key value pairs containing parameters to build OIDC core authorization request (RFC6749) for Issuer OIDC provider to perform wallet user authorization grant.
	AuthorizationRequest OAuthParameters `json:"authorization_request"`

	// Issuer's OIDC provider PAR endpoint.
	PushedAuthorizationRequestEndpoint *string `json:"pushed_authorization_request_endpoint,omitempty"`

	// Transaction ID to correlate upcoming authorization response.
	TxId                string                                `json:"tx_id"`
	WalletInitiatedFlow *externalRef0.WalletInitiatedFlowData `json:"wallet_initiated_flow"`
}

// Model for Prepare Credential request.
type PrepareCredential struct {
	// The "aud" claim received from the client.
	AudienceClaim string `json:"audienceClaim"`

	// DID to which issued credential has to be bound.
	Did *string `json:"did,omitempty"`

	// Format of the credential being issued.
	Format *string `json:"format,omitempty"`

	// Hashed token received from the client.
	HashedToken string `json:"hashed_token"`

	// Object containing requested information for encrypting the Credential Response.
	RequestedCredentialResponseEncryption *RequestedCredentialResponseEncryption `json:"requested_credential_response_encryption,omitempty"`

	// Transaction ID.
	TxId string `json:"tx_id"`

	// Array of types of the credential being issued.
	Types []string `json:"types"`
}

// Model for Prepare Credential response.
type PrepareCredentialResult struct {
	// String identifying an issued Credential that the Wallet includes in the acknowledgement request.
	AckId      *string     `json:"ack_id,omitempty"`
	Credential interface{} `json:"credential"`

	// Format of issued credential.
	Format string `json:"format"`

	// OIDC credential format
	OidcFormat string `json:"oidc_format"`

	// TRUE if claim data is not yet available in the issuer OP server. This will indicate VCS OIDC to issue acceptance_token instead of credential response (Deferred Credential flow).
	Retry bool `json:"retry"`
}

// Model for Push Authorization Details request.
type PushAuthorizationDetailsRequest struct {
	AuthorizationDetails []externalRef0.AuthorizationDetails `json:"authorization_details"`
	OpState              string                              `json:"op_state"`
}

// Object containing requested information for encrypting the Credential Response.
type RequestedCredentialResponseEncryption struct {
	// JWE alg algorithm for encrypting the Credential Response.
	Alg string `json:"alg"`

	// JWE enc algorithm for encrypting the Credential Response.
	Enc string `json:"enc"`
}

// Model for storing auth code from issuer oauth
type StoreAuthorizationCodeRequest struct {
	Code                string                                `json:"code"`
	OpState             string                                `json:"op_state"`
	WalletInitiatedFlow *externalRef0.WalletInitiatedFlowData `json:"wallet_initiated_flow"`
}

// Response model for storing auth code from issuer oauth
type StoreAuthorizationCodeResponse struct {
	TxId *string `json:"tx_id,omitempty"`
}

// UpdateCredentialStatusRequest request struct for updating VC status.
type UpdateCredentialStatusRequest struct {
	CredentialID string `json:"credentialID"`

	// Credential status.
	CredentialStatus CredentialStatus `json:"credentialStatus"`
	ProfileID        string           `json:"profileID"`
	ProfileVersion   string           `json:"profileVersion"`
}

// Model for validating pre-authorized code and pin.
type ValidatePreAuthorizedCodeRequest struct {
	// The value MUST contain two JWTs, separated by a "~" character. The first JWT is the client attestation JWT, the second is the client attestation PoP JWT.
	ClientAssertion *string `json:"client_assertion,omitempty"`

	// Specifies the method used to authenticate the client application to the authorization server (VCS). The only supported value is "urn:ietf:params:oauth:client-assertion-type:jwt-client-attestation". It indicates that the client must authenticate using OAuth 2.0 Attestation-Based Client Authentication method.
	ClientAssertionType *string `json:"client_assertion_type,omitempty"`

	// Client ID for VCS OIDC interaction.
	ClientId *string `json:"client_id,omitempty"`

	// Pre authorized code.
	PreAuthorizedCode string `json:"pre-authorized_code"`

	// User pin.
	UserPin *string `json:"user_pin,omitempty"`
}

// Model for validating pre-authorized code and pin.
type ValidatePreAuthorizedCodeResponse struct {
	// REQUIRED when authorization_details parameter is used to request issuance of a certain Credential type as defined in Section 5.1.1. It MUST NOT be used otherwise. It is an array of objects, as defined in Section 7 of [RFC9396].
	AuthorizationDetails *[]externalRef0.AuthorizationDetails `json:"authorization_details,omitempty"`

	// Op state.
	OpState string `json:"op_state"`

	// A list of pre-authorized scopes
	Scopes []string `json:"scopes"`

	// transaction id
	TxId string `json:"tx_id"`
}

// OpenID Config response.
type WellKnownOpenIDConfiguration struct {
	// URL of the OP's OAuth 2.0 Authorization Endpoint.
	AuthorizationEndpoint string `json:"authorization_endpoint"`

	// URL of the acknowledgement endpoint.
	CredentialAckEndpoint string `json:"credential_ack_endpoint"`

	// JSON array containing a list of the OAuth 2.0 Grant Type values that this OP supports.
	GrantTypesSupported []string `json:"grant_types_supported"`

	// JSON Boolean indicating whether the issuer accepts a Token Request with a Pre-Authorized Code but without a client id. The default is false.
	PreAuthorizedGrantAnonymousAccessSupported bool `json:"pre-authorized_grant_anonymous_access_supported"`

	// URL of the OP's Dynamic Client Registration Endpoint.
	RegistrationEndpoint *string `json:"registration_endpoint,omitempty"`

	// JSON array containing a list of the OAuth 2.0 response_type values that this OP supports.
	ResponseTypesSupported []string `json:"response_types_supported"`

	// JSON array containing a list of the OAuth 2.0 [RFC6749] scope values that this server supports.
	ScopesSupported []string `json:"scopes_supported"`

	// URL of the OP's OAuth 2.0 Token Endpoint.
	TokenEndpoint string `json:"token_endpoint"`

	// JSON Boolean indicating whether the issuer profile supports wallet initiated flow in OIDC4CI. The default is false.
	WalletInitiatedAuthFlowSupported bool `json:"wallet_initiated_auth_flow_supported"`
}

// WellKnownOpenIDIssuerConfiguration represents the OIDC Configuration response for cases when VCS serves as IDP.
type WellKnownOpenIDIssuerConfiguration struct {
	// URL of the OP's OAuth 2.0 Authorization Endpoint.
	AuthorizationEndpoint *string `json:"authorization_endpoint,omitempty"`

	// URL of the Credential Issuer's Batch Credential Endpoint. This URL MUST use the https scheme and MAY contain port, path and query parameter components. If omitted, the Credential Issuer does not support the Batch Credential Endpoint.
	BatchCredentialEndpoint *string `json:"batch_credential_endpoint,omitempty"`

	// URL of the acknowledgement endpoint.
	CredentialAckEndpoint *string `json:"credential_ack_endpoint,omitempty"`

	// An object that describes specifics of the Credential that the Credential Issuer supports issuance of. This object contains a list of name/value pairs, where each name is a unique identifier of the supported credential being described.
	CredentialConfigurationsSupported *WellKnownOpenIDIssuerConfiguration_CredentialConfigurationsSupported `json:"credential_configurations_supported,omitempty"`

	// URL of the Credential Issuer's Credential Endpoint. This URL MUST use the https scheme and MAY contain port, path and query parameter components.
	CredentialEndpoint *string `json:"credential_endpoint,omitempty"`

	// Boolean value specifying whether the Credential Issuer supports returning credential_identifiers parameter in the authorization_details Token Response parameter, with true indicating support. If omitted, the default value is false.
	CredentialIdentifiersSupported *bool `json:"credential_identifiers_supported,omitempty"`

	// The Credential Issuer's identifier.
	CredentialIssuer *string `json:"credential_issuer,omitempty"`

	// Object containing information about whether the Credential Issuer supports encryption of the Credential and Batch Credential Response on top of TLS
	CredentialResponseEncryption *CredentialResponseEncryptionSupported `json:"credential_response_encryption,omitempty"`

	// URL of the Credential Issuer's Deferred Credential Endpoint. This URL MUST use the https scheme and MAY contain port, path, and query parameter components. If omitted, the Credential Issuer does not support the Deferred Credential Endpoint.
	DeferredCredentialEndpoint *string `json:"deferred_credential_endpoint,omitempty"`

	// An array of objects, where each object contains display properties of a Credential Issuer for a certain language.
	Display *[]CredentialDisplay `json:"display,omitempty"`

	// JSON array containing a list of the OAuth 2.0 Grant Type values that this OP supports.
	GrantTypesSupported *[]string `json:"grant_types_supported,omitempty"`

	// URL of the Credential Issuer's Notification Endpoint. This URL MUST use the https scheme and MAY contain port, path, and query parameter components. If omitted, the Credential Issuer does not support the Notification Endpoint.
	NotificationEndpoint *string `json:"notification_endpoint,omitempty"`

	// JSON Boolean indicating whether the issuer accepts a Token Request with a Pre-Authorized Code but without a client id. The default is false.
	PreAuthorizedGrantAnonymousAccessSupported *bool `json:"pre-authorized_grant_anonymous_access_supported,omitempty"`

	// URL of the OP's Dynamic Client Registration Endpoint.
	RegistrationEndpoint *string `json:"registration_endpoint,omitempty"`

	// JSON array containing a list of the OAuth 2.0 response_type values that this OP supports.
	ResponseTypesSupported *[]string `json:"response_types_supported,omitempty"`

	// JSON array containing a list of the OAuth 2.0 [RFC6749] scope values that this server supports.
	ScopesSupported *[]string `json:"scopes_supported,omitempty"`

	// String that is a signed JWT. This JWT contains Credential Issuer metadata parameters as claims.
	SignedMetadata *string `json:"signed_metadata,omitempty"`

	// URL of the OP's OAuth 2.0 Token Endpoint.
	TokenEndpoint *string `json:"token_endpoint,omitempty"`

	// JSON array containing a list of client authentication methods supported by this token endpoint. Default is "none".
	TokenEndpointAuthMethodsSupported *[]string `json:"token_endpoint_auth_methods_supported,omitempty"`
}

// An object that describes specifics of the Credential that the Credential Issuer supports issuance of. This object contains a list of name/value pairs, where each name is a unique identifier of the supported credential being described.
type WellKnownOpenIDIssuerConfiguration_CredentialConfigurationsSupported struct {
	AdditionalProperties map[string]CredentialConfigurationsSupported `json:"-"`
}

// PostCredentialsStatusJSONBody defines parameters for PostCredentialsStatus.
type PostCredentialsStatusJSONBody = UpdateCredentialStatusRequest

// ExchangeAuthorizationCodeRequestJSONBody defines parameters for ExchangeAuthorizationCodeRequest.
type ExchangeAuthorizationCodeRequestJSONBody = ExchangeAuthorizationCodeRequest

// PrepareAuthorizationRequestJSONBody defines parameters for PrepareAuthorizationRequest.
type PrepareAuthorizationRequestJSONBody = PrepareClaimDataAuthorizationRequest

// PrepareCredentialJSONBody defines parameters for PrepareCredential.
type PrepareCredentialJSONBody = PrepareCredential

// PushAuthorizationDetailsJSONBody defines parameters for PushAuthorizationDetails.
type PushAuthorizationDetailsJSONBody = PushAuthorizationDetailsRequest

// StoreAuthorizationCodeRequestJSONBody defines parameters for StoreAuthorizationCodeRequest.
type StoreAuthorizationCodeRequestJSONBody = StoreAuthorizationCodeRequest

// ValidatePreAuthorizedCodeRequestJSONBody defines parameters for ValidatePreAuthorizedCodeRequest.
type ValidatePreAuthorizedCodeRequestJSONBody = ValidatePreAuthorizedCodeRequest

// PostIssueCredentialsJSONBody defines parameters for PostIssueCredentials.
type PostIssueCredentialsJSONBody = IssueCredentialData

// InitiateCredentialIssuanceJSONBody defines parameters for InitiateCredentialIssuance.
type InitiateCredentialIssuanceJSONBody = InitiateOIDC4CIRequest

// PostCredentialsStatusJSONRequestBody defines body for PostCredentialsStatus for application/json ContentType.
type PostCredentialsStatusJSONRequestBody = PostCredentialsStatusJSONBody

// ExchangeAuthorizationCodeRequestJSONRequestBody defines body for ExchangeAuthorizationCodeRequest for application/json ContentType.
type ExchangeAuthorizationCodeRequestJSONRequestBody = ExchangeAuthorizationCodeRequestJSONBody

// PrepareAuthorizationRequestJSONRequestBody defines body for PrepareAuthorizationRequest for application/json ContentType.
type PrepareAuthorizationRequestJSONRequestBody = PrepareAuthorizationRequestJSONBody

// PrepareCredentialJSONRequestBody defines body for PrepareCredential for application/json ContentType.
type PrepareCredentialJSONRequestBody = PrepareCredentialJSONBody

// PushAuthorizationDetailsJSONRequestBody defines body for PushAuthorizationDetails for application/json ContentType.
type PushAuthorizationDetailsJSONRequestBody = PushAuthorizationDetailsJSONBody

// StoreAuthorizationCodeRequestJSONRequestBody defines body for StoreAuthorizationCodeRequest for application/json ContentType.
type StoreAuthorizationCodeRequestJSONRequestBody = StoreAuthorizationCodeRequestJSONBody

// ValidatePreAuthorizedCodeRequestJSONRequestBody defines body for ValidatePreAuthorizedCodeRequest for application/json ContentType.
type ValidatePreAuthorizedCodeRequestJSONRequestBody = ValidatePreAuthorizedCodeRequestJSONBody

// PostIssueCredentialsJSONRequestBody defines body for PostIssueCredentials for application/json ContentType.
type PostIssueCredentialsJSONRequestBody = PostIssueCredentialsJSONBody

// InitiateCredentialIssuanceJSONRequestBody defines body for InitiateCredentialIssuance for application/json ContentType.
type InitiateCredentialIssuanceJSONRequestBody = InitiateCredentialIssuanceJSONBody

// Getter for additional properties for WellKnownOpenIDIssuerConfiguration_CredentialConfigurationsSupported. Returns the specified
// element and whether it was found
func (a WellKnownOpenIDIssuerConfiguration_CredentialConfigurationsSupported) Get(fieldName string) (value CredentialConfigurationsSupported, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for WellKnownOpenIDIssuerConfiguration_CredentialConfigurationsSupported
func (a *WellKnownOpenIDIssuerConfiguration_CredentialConfigurationsSupported) Set(fieldName string, value CredentialConfigurationsSupported) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]CredentialConfigurationsSupported)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for WellKnownOpenIDIssuerConfiguration_CredentialConfigurationsSupported to handle AdditionalProperties
func (a *WellKnownOpenIDIssuerConfiguration_CredentialConfigurationsSupported) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]CredentialConfigurationsSupported)
		for fieldName, fieldBuf := range object {
			var fieldVal CredentialConfigurationsSupported
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for WellKnownOpenIDIssuerConfiguration_CredentialConfigurationsSupported to handle AdditionalProperties
func (a WellKnownOpenIDIssuerConfiguration_CredentialConfigurationsSupported) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// PostCredentialsStatus request with any body
	PostCredentialsStatusWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCredentialsStatus(ctx context.Context, body PostCredentialsStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCredentialsStatus request
	GetCredentialsStatus(ctx context.Context, groupID string, statusID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExchangeAuthorizationCodeRequest request with any body
	ExchangeAuthorizationCodeRequestWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExchangeAuthorizationCodeRequest(ctx context.Context, body ExchangeAuthorizationCodeRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PrepareAuthorizationRequest request with any body
	PrepareAuthorizationRequestWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PrepareAuthorizationRequest(ctx context.Context, body PrepareAuthorizationRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PrepareCredential request with any body
	PrepareCredentialWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PrepareCredential(ctx context.Context, body PrepareCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PushAuthorizationDetails request with any body
	PushAuthorizationDetailsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PushAuthorizationDetails(ctx context.Context, body PushAuthorizationDetailsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StoreAuthorizationCodeRequest request with any body
	StoreAuthorizationCodeRequestWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreAuthorizationCodeRequest(ctx context.Context, body StoreAuthorizationCodeRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ValidatePreAuthorizedCodeRequest request with any body
	ValidatePreAuthorizedCodeRequestWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ValidatePreAuthorizedCodeRequest(ctx context.Context, body ValidatePreAuthorizedCodeRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CredentialIssuanceHistory request
	CredentialIssuanceHistory(ctx context.Context, profileID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostIssueCredentials request with any body
	PostIssueCredentialsWithBody(ctx context.Context, profileID string, profileVersion string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostIssueCredentials(ctx context.Context, profileID string, profileVersion string, body PostIssueCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InitiateCredentialIssuance request with any body
	InitiateCredentialIssuanceWithBody(ctx context.Context, profileID string, profileVersion string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InitiateCredentialIssuance(ctx context.Context, profileID string, profileVersion string, body InitiateCredentialIssuanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OpenidCredentialIssuerConfig request
	OpenidCredentialIssuerConfig(ctx context.Context, profileID string, profileVersion string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OpenidConfigV2 request
	OpenidConfigV2(ctx context.Context, profileID string, profileVersion string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OpenidCredentialIssuerConfigV2 request
	OpenidCredentialIssuerConfigV2(ctx context.Context, profileID string, profileVersion string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) PostCredentialsStatusWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCredentialsStatusRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCredentialsStatus(ctx context.Context, body PostCredentialsStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCredentialsStatusRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCredentialsStatus(ctx context.Context, groupID string, statusID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCredentialsStatusRequest(c.Server, groupID, statusID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExchangeAuthorizationCodeRequestWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExchangeAuthorizationCodeRequestRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExchangeAuthorizationCodeRequest(ctx context.Context, body ExchangeAuthorizationCodeRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExchangeAuthorizationCodeRequestRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PrepareAuthorizationRequestWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrepareAuthorizationRequestRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PrepareAuthorizationRequest(ctx context.Context, body PrepareAuthorizationRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrepareAuthorizationRequestRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PrepareCredentialWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrepareCredentialRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PrepareCredential(ctx context.Context, body PrepareCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrepareCredentialRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PushAuthorizationDetailsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPushAuthorizationDetailsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PushAuthorizationDetails(ctx context.Context, body PushAuthorizationDetailsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPushAuthorizationDetailsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreAuthorizationCodeRequestWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreAuthorizationCodeRequestRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreAuthorizationCodeRequest(ctx context.Context, body StoreAuthorizationCodeRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreAuthorizationCodeRequestRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidatePreAuthorizedCodeRequestWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidatePreAuthorizedCodeRequestRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidatePreAuthorizedCodeRequest(ctx context.Context, body ValidatePreAuthorizedCodeRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidatePreAuthorizedCodeRequestRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CredentialIssuanceHistory(ctx context.Context, profileID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCredentialIssuanceHistoryRequest(c.Server, profileID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostIssueCredentialsWithBody(ctx context.Context, profileID string, profileVersion string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostIssueCredentialsRequestWithBody(c.Server, profileID, profileVersion, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostIssueCredentials(ctx context.Context, profileID string, profileVersion string, body PostIssueCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostIssueCredentialsRequest(c.Server, profileID, profileVersion, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InitiateCredentialIssuanceWithBody(ctx context.Context, profileID string, profileVersion string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInitiateCredentialIssuanceRequestWithBody(c.Server, profileID, profileVersion, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InitiateCredentialIssuance(ctx context.Context, profileID string, profileVersion string, body InitiateCredentialIssuanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInitiateCredentialIssuanceRequest(c.Server, profileID, profileVersion, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OpenidCredentialIssuerConfig(ctx context.Context, profileID string, profileVersion string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOpenidCredentialIssuerConfigRequest(c.Server, profileID, profileVersion)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OpenidConfigV2(ctx context.Context, profileID string, profileVersion string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOpenidConfigV2Request(c.Server, profileID, profileVersion)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OpenidCredentialIssuerConfigV2(ctx context.Context, profileID string, profileVersion string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOpenidCredentialIssuerConfigV2Request(c.Server, profileID, profileVersion)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewPostCredentialsStatusRequest calls the generic PostCredentialsStatus builder with application/json body
func NewPostCredentialsStatusRequest(server string, body PostCredentialsStatusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCredentialsStatusRequestWithBody(server, "application/json", bodyReader)
}

// NewPostCredentialsStatusRequestWithBody generates requests for PostCredentialsStatus with any type of body
func NewPostCredentialsStatusRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issuer/credentials/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCredentialsStatusRequest generates requests for GetCredentialsStatus
func NewGetCredentialsStatusRequest(server string, groupID string, statusID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupID", runtime.ParamLocationPath, groupID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "statusID", runtime.ParamLocationPath, statusID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issuer/groups/%s/credentials/status/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExchangeAuthorizationCodeRequestRequest calls the generic ExchangeAuthorizationCodeRequest builder with application/json body
func NewExchangeAuthorizationCodeRequestRequest(server string, body ExchangeAuthorizationCodeRequestJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExchangeAuthorizationCodeRequestRequestWithBody(server, "application/json", bodyReader)
}

// NewExchangeAuthorizationCodeRequestRequestWithBody generates requests for ExchangeAuthorizationCodeRequest with any type of body
func NewExchangeAuthorizationCodeRequestRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issuer/interactions/exchange-authorization-code")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPrepareAuthorizationRequestRequest calls the generic PrepareAuthorizationRequest builder with application/json body
func NewPrepareAuthorizationRequestRequest(server string, body PrepareAuthorizationRequestJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPrepareAuthorizationRequestRequestWithBody(server, "application/json", bodyReader)
}

// NewPrepareAuthorizationRequestRequestWithBody generates requests for PrepareAuthorizationRequest with any type of body
func NewPrepareAuthorizationRequestRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issuer/interactions/prepare-claim-data-authz-request")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPrepareCredentialRequest calls the generic PrepareCredential builder with application/json body
func NewPrepareCredentialRequest(server string, body PrepareCredentialJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPrepareCredentialRequestWithBody(server, "application/json", bodyReader)
}

// NewPrepareCredentialRequestWithBody generates requests for PrepareCredential with any type of body
func NewPrepareCredentialRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issuer/interactions/prepare-credential")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPushAuthorizationDetailsRequest calls the generic PushAuthorizationDetails builder with application/json body
func NewPushAuthorizationDetailsRequest(server string, body PushAuthorizationDetailsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPushAuthorizationDetailsRequestWithBody(server, "application/json", bodyReader)
}

// NewPushAuthorizationDetailsRequestWithBody generates requests for PushAuthorizationDetails with any type of body
func NewPushAuthorizationDetailsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issuer/interactions/push-authorization-request")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStoreAuthorizationCodeRequestRequest calls the generic StoreAuthorizationCodeRequest builder with application/json body
func NewStoreAuthorizationCodeRequestRequest(server string, body StoreAuthorizationCodeRequestJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStoreAuthorizationCodeRequestRequestWithBody(server, "application/json", bodyReader)
}

// NewStoreAuthorizationCodeRequestRequestWithBody generates requests for StoreAuthorizationCodeRequest with any type of body
func NewStoreAuthorizationCodeRequestRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issuer/interactions/store-authorization-code")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewValidatePreAuthorizedCodeRequestRequest calls the generic ValidatePreAuthorizedCodeRequest builder with application/json body
func NewValidatePreAuthorizedCodeRequestRequest(server string, body ValidatePreAuthorizedCodeRequestJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewValidatePreAuthorizedCodeRequestRequestWithBody(server, "application/json", bodyReader)
}

// NewValidatePreAuthorizedCodeRequestRequestWithBody generates requests for ValidatePreAuthorizedCodeRequest with any type of body
func NewValidatePreAuthorizedCodeRequestRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issuer/interactions/validate-pre-authorized-code")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCredentialIssuanceHistoryRequest generates requests for CredentialIssuanceHistory
func NewCredentialIssuanceHistoryRequest(server string, profileID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "profileID", runtime.ParamLocationPath, profileID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issuer/profiles/%s/issued-credentials", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostIssueCredentialsRequest calls the generic PostIssueCredentials builder with application/json body
func NewPostIssueCredentialsRequest(server string, profileID string, profileVersion string, body PostIssueCredentialsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostIssueCredentialsRequestWithBody(server, profileID, profileVersion, "application/json", bodyReader)
}

// NewPostIssueCredentialsRequestWithBody generates requests for PostIssueCredentials with any type of body
func NewPostIssueCredentialsRequestWithBody(server string, profileID string, profileVersion string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "profileID", runtime.ParamLocationPath, profileID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "profileVersion", runtime.ParamLocationPath, profileVersion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issuer/profiles/%s/%s/credentials/issue", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInitiateCredentialIssuanceRequest calls the generic InitiateCredentialIssuance builder with application/json body
func NewInitiateCredentialIssuanceRequest(server string, profileID string, profileVersion string, body InitiateCredentialIssuanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInitiateCredentialIssuanceRequestWithBody(server, profileID, profileVersion, "application/json", bodyReader)
}

// NewInitiateCredentialIssuanceRequestWithBody generates requests for InitiateCredentialIssuance with any type of body
func NewInitiateCredentialIssuanceRequestWithBody(server string, profileID string, profileVersion string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "profileID", runtime.ParamLocationPath, profileID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "profileVersion", runtime.ParamLocationPath, profileVersion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issuer/profiles/%s/%s/interactions/initiate-oidc", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOpenidCredentialIssuerConfigRequest generates requests for OpenidCredentialIssuerConfig
func NewOpenidCredentialIssuerConfigRequest(server string, profileID string, profileVersion string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "profileID", runtime.ParamLocationPath, profileID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "profileVersion", runtime.ParamLocationPath, profileVersion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issuer/%s/%s/.well-known/openid-credential-issuer", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOpenidConfigV2Request generates requests for OpenidConfigV2
func NewOpenidConfigV2Request(server string, profileID string, profileVersion string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "profileID", runtime.ParamLocationPath, profileID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "profileVersion", runtime.ParamLocationPath, profileVersion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oidc/idp/%s/%s/.well-known/openid-configuration", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOpenidCredentialIssuerConfigV2Request generates requests for OpenidCredentialIssuerConfigV2
func NewOpenidCredentialIssuerConfigV2Request(server string, profileID string, profileVersion string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "profileID", runtime.ParamLocationPath, profileID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "profileVersion", runtime.ParamLocationPath, profileVersion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oidc/idp/%s/%s/.well-known/openid-credential-issuer", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// PostCredentialsStatus request with any body
	PostCredentialsStatusWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCredentialsStatusResponse, error)

	PostCredentialsStatusWithResponse(ctx context.Context, body PostCredentialsStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCredentialsStatusResponse, error)

	// GetCredentialsStatus request
	GetCredentialsStatusWithResponse(ctx context.Context, groupID string, statusID string, reqEditors ...RequestEditorFn) (*GetCredentialsStatusResponse, error)

	// ExchangeAuthorizationCodeRequest request with any body
	ExchangeAuthorizationCodeRequestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExchangeAuthorizationCodeRequestResponse, error)

	ExchangeAuthorizationCodeRequestWithResponse(ctx context.Context, body ExchangeAuthorizationCodeRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*ExchangeAuthorizationCodeRequestResponse, error)

	// PrepareAuthorizationRequest request with any body
	PrepareAuthorizationRequestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PrepareAuthorizationRequestResponse, error)

	PrepareAuthorizationRequestWithResponse(ctx context.Context, body PrepareAuthorizationRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*PrepareAuthorizationRequestResponse, error)

	// PrepareCredential request with any body
	PrepareCredentialWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PrepareCredentialResponse, error)

	PrepareCredentialWithResponse(ctx context.Context, body PrepareCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*PrepareCredentialResponse, error)

	// PushAuthorizationDetails request with any body
	PushAuthorizationDetailsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PushAuthorizationDetailsResponse, error)

	PushAuthorizationDetailsWithResponse(ctx context.Context, body PushAuthorizationDetailsJSONRequestBody, reqEditors ...RequestEditorFn) (*PushAuthorizationDetailsResponse, error)

	// StoreAuthorizationCodeRequest request with any body
	StoreAuthorizationCodeRequestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreAuthorizationCodeRequestResponse, error)

	StoreAuthorizationCodeRequestWithResponse(ctx context.Context, body StoreAuthorizationCodeRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreAuthorizationCodeRequestResponse, error)

	// ValidatePreAuthorizedCodeRequest request with any body
	ValidatePreAuthorizedCodeRequestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidatePreAuthorizedCodeRequestResponse, error)

	ValidatePreAuthorizedCodeRequestWithResponse(ctx context.Context, body ValidatePreAuthorizedCodeRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidatePreAuthorizedCodeRequestResponse, error)

	// CredentialIssuanceHistory request
	CredentialIssuanceHistoryWithResponse(ctx context.Context, profileID string, reqEditors ...RequestEditorFn) (*CredentialIssuanceHistoryResponse, error)

	// PostIssueCredentials request with any body
	PostIssueCredentialsWithBodyWithResponse(ctx context.Context, profileID string, profileVersion string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostIssueCredentialsResponse, error)

	PostIssueCredentialsWithResponse(ctx context.Context, profileID string, profileVersion string, body PostIssueCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostIssueCredentialsResponse, error)

	// InitiateCredentialIssuance request with any body
	InitiateCredentialIssuanceWithBodyWithResponse(ctx context.Context, profileID string, profileVersion string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InitiateCredentialIssuanceResponse, error)

	InitiateCredentialIssuanceWithResponse(ctx context.Context, profileID string, profileVersion string, body InitiateCredentialIssuanceJSONRequestBody, reqEditors ...RequestEditorFn) (*InitiateCredentialIssuanceResponse, error)

	// OpenidCredentialIssuerConfig request
	OpenidCredentialIssuerConfigWithResponse(ctx context.Context, profileID string, profileVersion string, reqEditors ...RequestEditorFn) (*OpenidCredentialIssuerConfigResponse, error)

	// OpenidConfigV2 request
	OpenidConfigV2WithResponse(ctx context.Context, profileID string, profileVersion string, reqEditors ...RequestEditorFn) (*OpenidConfigV2Response, error)

	// OpenidCredentialIssuerConfigV2 request
	OpenidCredentialIssuerConfigV2WithResponse(ctx context.Context, profileID string, profileVersion string, reqEditors ...RequestEditorFn) (*OpenidCredentialIssuerConfigV2Response, error)
}

type PostCredentialsStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r PostCredentialsStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCredentialsStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCredentialsStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r GetCredentialsStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCredentialsStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExchangeAuthorizationCodeRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExchangeAuthorizationCodeResponse
}

// Status returns HTTPResponse.Status
func (r ExchangeAuthorizationCodeRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExchangeAuthorizationCodeRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PrepareAuthorizationRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PrepareClaimDataAuthorizationResponse
}

// Status returns HTTPResponse.Status
func (r PrepareAuthorizationRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PrepareAuthorizationRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PrepareCredentialResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PrepareCredentialResult
}

// Status returns HTTPResponse.Status
func (r PrepareCredentialResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PrepareCredentialResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PushAuthorizationDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PushAuthorizationDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PushAuthorizationDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StoreAuthorizationCodeRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StoreAuthorizationCodeResponse
}

// Status returns HTTPResponse.Status
func (r StoreAuthorizationCodeRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StoreAuthorizationCodeRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ValidatePreAuthorizedCodeRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ValidatePreAuthorizedCodeResponse
}

// Status returns HTTPResponse.Status
func (r ValidatePreAuthorizedCodeRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidatePreAuthorizedCodeRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CredentialIssuanceHistoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CredentialIssuanceHistoryData
}

// Status returns HTTPResponse.Status
func (r CredentialIssuanceHistoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CredentialIssuanceHistoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostIssueCredentialsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r PostIssueCredentialsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostIssueCredentialsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InitiateCredentialIssuanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InitiateOIDC4CIResponse
}

// Status returns HTTPResponse.Status
func (r InitiateCredentialIssuanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InitiateCredentialIssuanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OpenidCredentialIssuerConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WellKnownOpenIDIssuerConfiguration
}

// Status returns HTTPResponse.Status
func (r OpenidCredentialIssuerConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OpenidCredentialIssuerConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OpenidConfigV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WellKnownOpenIDConfiguration
}

// Status returns HTTPResponse.Status
func (r OpenidConfigV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OpenidConfigV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OpenidCredentialIssuerConfigV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WellKnownOpenIDIssuerConfiguration
}

// Status returns HTTPResponse.Status
func (r OpenidCredentialIssuerConfigV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OpenidCredentialIssuerConfigV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// PostCredentialsStatusWithBodyWithResponse request with arbitrary body returning *PostCredentialsStatusResponse
func (c *ClientWithResponses) PostCredentialsStatusWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCredentialsStatusResponse, error) {
	rsp, err := c.PostCredentialsStatusWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCredentialsStatusResponse(rsp)
}

func (c *ClientWithResponses) PostCredentialsStatusWithResponse(ctx context.Context, body PostCredentialsStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCredentialsStatusResponse, error) {
	rsp, err := c.PostCredentialsStatus(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCredentialsStatusResponse(rsp)
}

// GetCredentialsStatusWithResponse request returning *GetCredentialsStatusResponse
func (c *ClientWithResponses) GetCredentialsStatusWithResponse(ctx context.Context, groupID string, statusID string, reqEditors ...RequestEditorFn) (*GetCredentialsStatusResponse, error) {
	rsp, err := c.GetCredentialsStatus(ctx, groupID, statusID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCredentialsStatusResponse(rsp)
}

// ExchangeAuthorizationCodeRequestWithBodyWithResponse request with arbitrary body returning *ExchangeAuthorizationCodeRequestResponse
func (c *ClientWithResponses) ExchangeAuthorizationCodeRequestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExchangeAuthorizationCodeRequestResponse, error) {
	rsp, err := c.ExchangeAuthorizationCodeRequestWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExchangeAuthorizationCodeRequestResponse(rsp)
}

func (c *ClientWithResponses) ExchangeAuthorizationCodeRequestWithResponse(ctx context.Context, body ExchangeAuthorizationCodeRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*ExchangeAuthorizationCodeRequestResponse, error) {
	rsp, err := c.ExchangeAuthorizationCodeRequest(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExchangeAuthorizationCodeRequestResponse(rsp)
}

// PrepareAuthorizationRequestWithBodyWithResponse request with arbitrary body returning *PrepareAuthorizationRequestResponse
func (c *ClientWithResponses) PrepareAuthorizationRequestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PrepareAuthorizationRequestResponse, error) {
	rsp, err := c.PrepareAuthorizationRequestWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrepareAuthorizationRequestResponse(rsp)
}

func (c *ClientWithResponses) PrepareAuthorizationRequestWithResponse(ctx context.Context, body PrepareAuthorizationRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*PrepareAuthorizationRequestResponse, error) {
	rsp, err := c.PrepareAuthorizationRequest(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrepareAuthorizationRequestResponse(rsp)
}

// PrepareCredentialWithBodyWithResponse request with arbitrary body returning *PrepareCredentialResponse
func (c *ClientWithResponses) PrepareCredentialWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PrepareCredentialResponse, error) {
	rsp, err := c.PrepareCredentialWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrepareCredentialResponse(rsp)
}

func (c *ClientWithResponses) PrepareCredentialWithResponse(ctx context.Context, body PrepareCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (*PrepareCredentialResponse, error) {
	rsp, err := c.PrepareCredential(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrepareCredentialResponse(rsp)
}

// PushAuthorizationDetailsWithBodyWithResponse request with arbitrary body returning *PushAuthorizationDetailsResponse
func (c *ClientWithResponses) PushAuthorizationDetailsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PushAuthorizationDetailsResponse, error) {
	rsp, err := c.PushAuthorizationDetailsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePushAuthorizationDetailsResponse(rsp)
}

func (c *ClientWithResponses) PushAuthorizationDetailsWithResponse(ctx context.Context, body PushAuthorizationDetailsJSONRequestBody, reqEditors ...RequestEditorFn) (*PushAuthorizationDetailsResponse, error) {
	rsp, err := c.PushAuthorizationDetails(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePushAuthorizationDetailsResponse(rsp)
}

// StoreAuthorizationCodeRequestWithBodyWithResponse request with arbitrary body returning *StoreAuthorizationCodeRequestResponse
func (c *ClientWithResponses) StoreAuthorizationCodeRequestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreAuthorizationCodeRequestResponse, error) {
	rsp, err := c.StoreAuthorizationCodeRequestWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreAuthorizationCodeRequestResponse(rsp)
}

func (c *ClientWithResponses) StoreAuthorizationCodeRequestWithResponse(ctx context.Context, body StoreAuthorizationCodeRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreAuthorizationCodeRequestResponse, error) {
	rsp, err := c.StoreAuthorizationCodeRequest(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreAuthorizationCodeRequestResponse(rsp)
}

// ValidatePreAuthorizedCodeRequestWithBodyWithResponse request with arbitrary body returning *ValidatePreAuthorizedCodeRequestResponse
func (c *ClientWithResponses) ValidatePreAuthorizedCodeRequestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidatePreAuthorizedCodeRequestResponse, error) {
	rsp, err := c.ValidatePreAuthorizedCodeRequestWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidatePreAuthorizedCodeRequestResponse(rsp)
}

func (c *ClientWithResponses) ValidatePreAuthorizedCodeRequestWithResponse(ctx context.Context, body ValidatePreAuthorizedCodeRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidatePreAuthorizedCodeRequestResponse, error) {
	rsp, err := c.ValidatePreAuthorizedCodeRequest(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidatePreAuthorizedCodeRequestResponse(rsp)
}

// CredentialIssuanceHistoryWithResponse request returning *CredentialIssuanceHistoryResponse
func (c *ClientWithResponses) CredentialIssuanceHistoryWithResponse(ctx context.Context, profileID string, reqEditors ...RequestEditorFn) (*CredentialIssuanceHistoryResponse, error) {
	rsp, err := c.CredentialIssuanceHistory(ctx, profileID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCredentialIssuanceHistoryResponse(rsp)
}

// PostIssueCredentialsWithBodyWithResponse request with arbitrary body returning *PostIssueCredentialsResponse
func (c *ClientWithResponses) PostIssueCredentialsWithBodyWithResponse(ctx context.Context, profileID string, profileVersion string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostIssueCredentialsResponse, error) {
	rsp, err := c.PostIssueCredentialsWithBody(ctx, profileID, profileVersion, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostIssueCredentialsResponse(rsp)
}

func (c *ClientWithResponses) PostIssueCredentialsWithResponse(ctx context.Context, profileID string, profileVersion string, body PostIssueCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostIssueCredentialsResponse, error) {
	rsp, err := c.PostIssueCredentials(ctx, profileID, profileVersion, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostIssueCredentialsResponse(rsp)
}

// InitiateCredentialIssuanceWithBodyWithResponse request with arbitrary body returning *InitiateCredentialIssuanceResponse
func (c *ClientWithResponses) InitiateCredentialIssuanceWithBodyWithResponse(ctx context.Context, profileID string, profileVersion string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InitiateCredentialIssuanceResponse, error) {
	rsp, err := c.InitiateCredentialIssuanceWithBody(ctx, profileID, profileVersion, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInitiateCredentialIssuanceResponse(rsp)
}

func (c *ClientWithResponses) InitiateCredentialIssuanceWithResponse(ctx context.Context, profileID string, profileVersion string, body InitiateCredentialIssuanceJSONRequestBody, reqEditors ...RequestEditorFn) (*InitiateCredentialIssuanceResponse, error) {
	rsp, err := c.InitiateCredentialIssuance(ctx, profileID, profileVersion, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInitiateCredentialIssuanceResponse(rsp)
}

// OpenidCredentialIssuerConfigWithResponse request returning *OpenidCredentialIssuerConfigResponse
func (c *ClientWithResponses) OpenidCredentialIssuerConfigWithResponse(ctx context.Context, profileID string, profileVersion string, reqEditors ...RequestEditorFn) (*OpenidCredentialIssuerConfigResponse, error) {
	rsp, err := c.OpenidCredentialIssuerConfig(ctx, profileID, profileVersion, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOpenidCredentialIssuerConfigResponse(rsp)
}

// OpenidConfigV2WithResponse request returning *OpenidConfigV2Response
func (c *ClientWithResponses) OpenidConfigV2WithResponse(ctx context.Context, profileID string, profileVersion string, reqEditors ...RequestEditorFn) (*OpenidConfigV2Response, error) {
	rsp, err := c.OpenidConfigV2(ctx, profileID, profileVersion, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOpenidConfigV2Response(rsp)
}

// OpenidCredentialIssuerConfigV2WithResponse request returning *OpenidCredentialIssuerConfigV2Response
func (c *ClientWithResponses) OpenidCredentialIssuerConfigV2WithResponse(ctx context.Context, profileID string, profileVersion string, reqEditors ...RequestEditorFn) (*OpenidCredentialIssuerConfigV2Response, error) {
	rsp, err := c.OpenidCredentialIssuerConfigV2(ctx, profileID, profileVersion, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOpenidCredentialIssuerConfigV2Response(rsp)
}

// ParsePostCredentialsStatusResponse parses an HTTP response from a PostCredentialsStatusWithResponse call
func ParsePostCredentialsStatusResponse(rsp *http.Response) (*PostCredentialsStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCredentialsStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCredentialsStatusResponse parses an HTTP response from a GetCredentialsStatusWithResponse call
func ParseGetCredentialsStatusResponse(rsp *http.Response) (*GetCredentialsStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCredentialsStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseExchangeAuthorizationCodeRequestResponse parses an HTTP response from a ExchangeAuthorizationCodeRequestWithResponse call
func ParseExchangeAuthorizationCodeRequestResponse(rsp *http.Response) (*ExchangeAuthorizationCodeRequestResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExchangeAuthorizationCodeRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExchangeAuthorizationCodeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePrepareAuthorizationRequestResponse parses an HTTP response from a PrepareAuthorizationRequestWithResponse call
func ParsePrepareAuthorizationRequestResponse(rsp *http.Response) (*PrepareAuthorizationRequestResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PrepareAuthorizationRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PrepareClaimDataAuthorizationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePrepareCredentialResponse parses an HTTP response from a PrepareCredentialWithResponse call
func ParsePrepareCredentialResponse(rsp *http.Response) (*PrepareCredentialResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PrepareCredentialResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PrepareCredentialResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePushAuthorizationDetailsResponse parses an HTTP response from a PushAuthorizationDetailsWithResponse call
func ParsePushAuthorizationDetailsResponse(rsp *http.Response) (*PushAuthorizationDetailsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PushAuthorizationDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseStoreAuthorizationCodeRequestResponse parses an HTTP response from a StoreAuthorizationCodeRequestWithResponse call
func ParseStoreAuthorizationCodeRequestResponse(rsp *http.Response) (*StoreAuthorizationCodeRequestResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StoreAuthorizationCodeRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StoreAuthorizationCodeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseValidatePreAuthorizedCodeRequestResponse parses an HTTP response from a ValidatePreAuthorizedCodeRequestWithResponse call
func ParseValidatePreAuthorizedCodeRequestResponse(rsp *http.Response) (*ValidatePreAuthorizedCodeRequestResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ValidatePreAuthorizedCodeRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ValidatePreAuthorizedCodeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCredentialIssuanceHistoryResponse parses an HTTP response from a CredentialIssuanceHistoryWithResponse call
func ParseCredentialIssuanceHistoryResponse(rsp *http.Response) (*CredentialIssuanceHistoryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CredentialIssuanceHistoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CredentialIssuanceHistoryData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostIssueCredentialsResponse parses an HTTP response from a PostIssueCredentialsWithResponse call
func ParsePostIssueCredentialsResponse(rsp *http.Response) (*PostIssueCredentialsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostIssueCredentialsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseInitiateCredentialIssuanceResponse parses an HTTP response from a InitiateCredentialIssuanceWithResponse call
func ParseInitiateCredentialIssuanceResponse(rsp *http.Response) (*InitiateCredentialIssuanceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InitiateCredentialIssuanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InitiateOIDC4CIResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseOpenidCredentialIssuerConfigResponse parses an HTTP response from a OpenidCredentialIssuerConfigWithResponse call
func ParseOpenidCredentialIssuerConfigResponse(rsp *http.Response) (*OpenidCredentialIssuerConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OpenidCredentialIssuerConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WellKnownOpenIDIssuerConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseOpenidConfigV2Response parses an HTTP response from a OpenidConfigV2WithResponse call
func ParseOpenidConfigV2Response(rsp *http.Response) (*OpenidConfigV2Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OpenidConfigV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WellKnownOpenIDConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseOpenidCredentialIssuerConfigV2Response parses an HTTP response from a OpenidCredentialIssuerConfigV2WithResponse call
func ParseOpenidCredentialIssuerConfigV2Response(rsp *http.Response) (*OpenidCredentialIssuerConfigV2Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OpenidCredentialIssuerConfigV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WellKnownOpenIDIssuerConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Updates credential status.
	// (POST /issuer/credentials/status)
	PostCredentialsStatus(ctx echo.Context) error
	// Retrieves the credential status.
	// (GET /issuer/groups/{groupID}/credentials/status/{statusID})
	GetCredentialsStatus(ctx echo.Context, groupID string, statusID string) error
	// Exchange authorization code from issuer oauth provider
	// (POST /issuer/interactions/exchange-authorization-code)
	ExchangeAuthorizationCodeRequest(ctx echo.Context) error
	// Prepare Claim Data Authorization Request
	// (POST /issuer/interactions/prepare-claim-data-authz-request)
	PrepareAuthorizationRequest(ctx echo.Context) error
	// Prepare Credential
	// (POST /issuer/interactions/prepare-credential)
	PrepareCredential(ctx echo.Context) error
	// Push Authorization Details
	// (POST /issuer/interactions/push-authorization-request)
	PushAuthorizationDetails(ctx echo.Context) error
	// Stores authorization code from issuer oauth provider
	// (POST /issuer/interactions/store-authorization-code)
	StoreAuthorizationCodeRequest(ctx echo.Context) error
	// Validates pre-authorized code and user pin
	// (POST /issuer/interactions/validate-pre-authorized-code)
	ValidatePreAuthorizedCodeRequest(ctx echo.Context) error
	// Request Credential Issuance history.
	// (GET /issuer/profiles/{profileID}/issued-credentials)
	CredentialIssuanceHistory(ctx echo.Context, profileID string) error
	// Issue credential
	// (POST /issuer/profiles/{profileID}/{profileVersion}/credentials/issue)
	PostIssueCredentials(ctx echo.Context, profileID string, profileVersion string) error
	// Initiate OIDC Credential Issuance
	// (POST /issuer/profiles/{profileID}/{profileVersion}/interactions/initiate-oidc)
	InitiateCredentialIssuance(ctx echo.Context, profileID string, profileVersion string) error
	// Request VCS IDP OIDC Configuration.
	// (GET /issuer/{profileID}/{profileVersion}/.well-known/openid-credential-issuer)
	OpenidCredentialIssuerConfig(ctx echo.Context, profileID string, profileVersion string) error
	// Request openid-config public endpoint.
	// (GET /oidc/idp/{profileID}/{profileVersion}/.well-known/openid-configuration)
	OpenidConfigV2(ctx echo.Context, profileID string, profileVersion string) error
	// Request VCS IDP OIDC Configuration.
	// (GET /oidc/idp/{profileID}/{profileVersion}/.well-known/openid-credential-issuer)
	OpenidCredentialIssuerConfigV2(ctx echo.Context, profileID string, profileVersion string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// PostCredentialsStatus converts echo context to params.
func (w *ServerInterfaceWrapper) PostCredentialsStatus(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostCredentialsStatus(ctx)
	return err
}

// GetCredentialsStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetCredentialsStatus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "groupID" -------------
	var groupID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "groupID", runtime.ParamLocationPath, ctx.Param("groupID"), &groupID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter groupID: %s", err))
	}

	// ------------- Path parameter "statusID" -------------
	var statusID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "statusID", runtime.ParamLocationPath, ctx.Param("statusID"), &statusID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter statusID: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCredentialsStatus(ctx, groupID, statusID)
	return err
}

// ExchangeAuthorizationCodeRequest converts echo context to params.
func (w *ServerInterfaceWrapper) ExchangeAuthorizationCodeRequest(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ExchangeAuthorizationCodeRequest(ctx)
	return err
}

// PrepareAuthorizationRequest converts echo context to params.
func (w *ServerInterfaceWrapper) PrepareAuthorizationRequest(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PrepareAuthorizationRequest(ctx)
	return err
}

// PrepareCredential converts echo context to params.
func (w *ServerInterfaceWrapper) PrepareCredential(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PrepareCredential(ctx)
	return err
}

// PushAuthorizationDetails converts echo context to params.
func (w *ServerInterfaceWrapper) PushAuthorizationDetails(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PushAuthorizationDetails(ctx)
	return err
}

// StoreAuthorizationCodeRequest converts echo context to params.
func (w *ServerInterfaceWrapper) StoreAuthorizationCodeRequest(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.StoreAuthorizationCodeRequest(ctx)
	return err
}

// ValidatePreAuthorizedCodeRequest converts echo context to params.
func (w *ServerInterfaceWrapper) ValidatePreAuthorizedCodeRequest(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ValidatePreAuthorizedCodeRequest(ctx)
	return err
}

// CredentialIssuanceHistory converts echo context to params.
func (w *ServerInterfaceWrapper) CredentialIssuanceHistory(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "profileID" -------------
	var profileID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "profileID", runtime.ParamLocationPath, ctx.Param("profileID"), &profileID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter profileID: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CredentialIssuanceHistory(ctx, profileID)
	return err
}

// PostIssueCredentials converts echo context to params.
func (w *ServerInterfaceWrapper) PostIssueCredentials(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "profileID" -------------
	var profileID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "profileID", runtime.ParamLocationPath, ctx.Param("profileID"), &profileID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter profileID: %s", err))
	}

	// ------------- Path parameter "profileVersion" -------------
	var profileVersion string

	err = runtime.BindStyledParameterWithLocation("simple", false, "profileVersion", runtime.ParamLocationPath, ctx.Param("profileVersion"), &profileVersion)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter profileVersion: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostIssueCredentials(ctx, profileID, profileVersion)
	return err
}

// InitiateCredentialIssuance converts echo context to params.
func (w *ServerInterfaceWrapper) InitiateCredentialIssuance(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "profileID" -------------
	var profileID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "profileID", runtime.ParamLocationPath, ctx.Param("profileID"), &profileID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter profileID: %s", err))
	}

	// ------------- Path parameter "profileVersion" -------------
	var profileVersion string

	err = runtime.BindStyledParameterWithLocation("simple", false, "profileVersion", runtime.ParamLocationPath, ctx.Param("profileVersion"), &profileVersion)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter profileVersion: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.InitiateCredentialIssuance(ctx, profileID, profileVersion)
	return err
}

// OpenidCredentialIssuerConfig converts echo context to params.
func (w *ServerInterfaceWrapper) OpenidCredentialIssuerConfig(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "profileID" -------------
	var profileID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "profileID", runtime.ParamLocationPath, ctx.Param("profileID"), &profileID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter profileID: %s", err))
	}

	// ------------- Path parameter "profileVersion" -------------
	var profileVersion string

	err = runtime.BindStyledParameterWithLocation("simple", false, "profileVersion", runtime.ParamLocationPath, ctx.Param("profileVersion"), &profileVersion)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter profileVersion: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.OpenidCredentialIssuerConfig(ctx, profileID, profileVersion)
	return err
}

// OpenidConfigV2 converts echo context to params.
func (w *ServerInterfaceWrapper) OpenidConfigV2(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "profileID" -------------
	var profileID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "profileID", runtime.ParamLocationPath, ctx.Param("profileID"), &profileID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter profileID: %s", err))
	}

	// ------------- Path parameter "profileVersion" -------------
	var profileVersion string

	err = runtime.BindStyledParameterWithLocation("simple", false, "profileVersion", runtime.ParamLocationPath, ctx.Param("profileVersion"), &profileVersion)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter profileVersion: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.OpenidConfigV2(ctx, profileID, profileVersion)
	return err
}

// OpenidCredentialIssuerConfigV2 converts echo context to params.
func (w *ServerInterfaceWrapper) OpenidCredentialIssuerConfigV2(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "profileID" -------------
	var profileID string

	err = runtime.BindStyledParameterWithLocation("simple", false, "profileID", runtime.ParamLocationPath, ctx.Param("profileID"), &profileID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter profileID: %s", err))
	}

	// ------------- Path parameter "profileVersion" -------------
	var profileVersion string

	err = runtime.BindStyledParameterWithLocation("simple", false, "profileVersion", runtime.ParamLocationPath, ctx.Param("profileVersion"), &profileVersion)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter profileVersion: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.OpenidCredentialIssuerConfigV2(ctx, profileID, profileVersion)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/issuer/credentials/status", wrapper.PostCredentialsStatus)
	router.GET(baseURL+"/issuer/groups/:groupID/credentials/status/:statusID", wrapper.GetCredentialsStatus)
	router.POST(baseURL+"/issuer/interactions/exchange-authorization-code", wrapper.ExchangeAuthorizationCodeRequest)
	router.POST(baseURL+"/issuer/interactions/prepare-claim-data-authz-request", wrapper.PrepareAuthorizationRequest)
	router.POST(baseURL+"/issuer/interactions/prepare-credential", wrapper.PrepareCredential)
	router.POST(baseURL+"/issuer/interactions/push-authorization-request", wrapper.PushAuthorizationDetails)
	router.POST(baseURL+"/issuer/interactions/store-authorization-code", wrapper.StoreAuthorizationCodeRequest)
	router.POST(baseURL+"/issuer/interactions/validate-pre-authorized-code", wrapper.ValidatePreAuthorizedCodeRequest)
	router.GET(baseURL+"/issuer/profiles/:profileID/issued-credentials", wrapper.CredentialIssuanceHistory)
	router.POST(baseURL+"/issuer/profiles/:profileID/:profileVersion/credentials/issue", wrapper.PostIssueCredentials)
	router.POST(baseURL+"/issuer/profiles/:profileID/:profileVersion/interactions/initiate-oidc", wrapper.InitiateCredentialIssuance)
	router.GET(baseURL+"/issuer/:profileID/:profileVersion/.well-known/openid-credential-issuer", wrapper.OpenidCredentialIssuerConfig)
	router.GET(baseURL+"/oidc/idp/:profileID/:profileVersion/.well-known/openid-configuration", wrapper.OpenidConfigV2)
	router.GET(baseURL+"/oidc/idp/:profileID/:profileVersion/.well-known/openid-credential-issuer", wrapper.OpenidCredentialIssuerConfigV2)

}
