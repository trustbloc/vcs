// Package oidc4ci provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package oidc4ci

import (
	"fmt"
	"net/http"

	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	externalRef0 "github.com/trustbloc/vcs/pkg/restapi/v1/common"
)

// AccessTokenResponse Model for Access Token Response.
type AccessTokenResponse struct {
	// AccessToken The access token issued by the authorization server.
	AccessToken string `json:"access_token"`

	// AuthorizationDetails REQUIRED when authorization_details parameter is used to request issuance of a certain Credential type as defined in Section 5.1.1. It MUST NOT be used otherwise. It is an array of objects, as defined in Section 7 of [RFC9396].
	AuthorizationDetails *[]externalRef0.AuthorizationDetails `json:"authorization_details,omitempty"`

	// CNonce String containing a nonce to be used to create a proof of possession of key material when requesting a credential.
	CNonce *string `json:"c_nonce,omitempty"`

	// CNonceExpiresIn Integer denoting the lifetime in seconds of the c_nonce.
	CNonceExpiresIn *int `json:"c_nonce_expires_in,omitempty"`

	// ExpiresIn The lifetime in seconds of the access token.
	ExpiresIn *int `json:"expires_in,omitempty"`

	// RefreshToken The refresh token, which can be used to obtain new access tokens.
	RefreshToken *string `json:"refresh_token,omitempty"`

	// Scope OPTIONAL, if identical to the scope requested by the client; otherwise, REQUIRED.
	Scope *string `json:"scope,omitempty"`

	// TokenType The type of the token issued.
	TokenType string `json:"token_type"`
}

// AckRequest Ack request.
type AckRequest struct {
	// Event Type of the notification event. According to draft 13 spec.
	Event string `json:"event"`

	// EventDescription Human-readable ASCII text providing additional information, used to assist the Credential Issuer developer in understanding the event that occurred. According to draft 13 spec.
	EventDescription *string `json:"event_description,omitempty"`

	// InteractionDetails Proprietary interaction details.
	InteractionDetails *map[string]interface{} `json:"interaction_details,omitempty"`

	// IssuerIdentifier Optional issuer identifier. Proprietary.
	IssuerIdentifier *string `json:"issuer_identifier,omitempty"`

	// NotificationId Ack ID. According to draft 13 spec.
	NotificationId string `json:"notification_id"`
}

// BatchCredentialRequest Model for OIDC batch Credential request.
type BatchCredentialRequest struct {
	CredentialRequests []CredentialRequest `json:"credential_requests"`
}

// BatchCredentialResponse Model for OIDC Batch Credential response.
type BatchCredentialResponse struct {
	// CNonce JSON string containing a nonce to be used to create a proof of possession of key material when requesting a Credential.
	CNonce *string `json:"c_nonce,omitempty"`

	// CNonceExpiresIn JSON integer denoting the lifetime in seconds of the c_nonce.
	CNonceExpiresIn     *int  `json:"c_nonce_expires_in,omitempty"`
	CredentialResponses []any `json:"credential_responses"`
}

// CredentialRequest Model for OIDC Credential request.
type CredentialRequest struct {
	// CredentialDefinition Object containing the detailed description of the credential type.
	CredentialDefinition *externalRef0.CredentialDefinition `json:"credential_definition,omitempty"`

	// CredentialIdentifier String that identifies a Credential that is being requested to be issued. When this parameter is used, the format parameter and any other Credential format specific parameters MUST NOT be present.
	CredentialIdentifier *string `json:"credential_identifier,omitempty"`

	// CredentialResponseEncryption Object containing information for encrypting the Credential Response.
	CredentialResponseEncryption *CredentialResponseEncryption `json:"credential_response_encryption,omitempty"`

	// Format Format of the credential being issued.
	Format *string   `json:"format,omitempty"`
	Proof  *JWTProof `json:"proof,omitempty"`
}

// CredentialResponse Model for OIDC Credential response.
type CredentialResponse struct {
	// CNonce JSON string containing a nonce to be used to create a proof of possession of key material when requesting a Credential. According to draft 13 spec.
	CNonce *string `json:"c_nonce,omitempty"`

	// CNonceExpiresIn JSON integer denoting the lifetime in seconds of the c_nonce. According to draft 13 spec.
	CNonceExpiresIn *int `json:"c_nonce_expires_in,omitempty"`

	// Credential Credential value. According to draft 13 spec.
	Credential any `json:"credential"`

	// Credentials Contains an array of one or more issued Credentials. According to editor-draft spec.
	Credentials []externalRef0.CredentialResponseCredentialObject `json:"credentials"`

	// NotificationId String identifying one or more Credentials issued in one Credential Response.
	NotificationId string `json:"notification_id"`

	// TransactionId A JSON string containing a token subsequently used to obtain a Credential. MUST be present when credential is not returned.
	TransactionId *string `json:"transaction_id,omitempty"`
}

// CredentialResponseBatchCredential Credential element Batch Credential Response.
type CredentialResponseBatchCredential struct {
	// Credential Contains issued Credential.
	Credential any `json:"credential"`

	// NotificationId String identifying an issued Credential that the Wallet includes in the acknowledgement request.
	NotificationId *string `json:"notification_id,omitempty"`

	// TransactionId OPTIONAL. String identifying a Deferred Issuance transaction. This claim is contained in the response if the Credential Issuer was unable to immediately issue the Credential. The value is subsequently used to obtain the respective Credential with the Deferred Credential Endpoint.
	TransactionId *string `json:"transaction_id,omitempty"`
}

// CredentialResponseEncryption Object containing information for encrypting the Credential Response.
type CredentialResponseEncryption struct {
	// Alg JWE alg algorithm for encrypting the Credential Response.
	Alg string `json:"alg"`

	// Enc JWE enc algorithm for encrypting the Credential Response.
	Enc string `json:"enc"`

	// Jwk Object containing a single public key as a JWK used for encrypting the Credential Response.
	Jwk string `json:"jwk"`
}

// JWTProof defines model for JWTProof.
type JWTProof struct {
	// Cwt REQUIRED if proof_type equals cwt. Signed CWT as proof of key possession.
	Cwt *string `json:"cwt,omitempty"`

	// Jwt REQUIRED if proof_type equals jwt. Signed JWT as proof of key possession.
	Jwt *string `json:"jwt,omitempty"`

	// LdpVp REQUIRED if proof_type equals ldp_vp. Linked Data Proof as proof of key possession.
	LdpVp *map[string]interface{} `json:"ldp_vp"`

	// ProofType REQUIRED. JSON String denoting the proof type. Currently the only supported proof type is 'jwt'.
	ProofType string `json:"proof_type"`
}

// PushedAuthorizationResponse Model for Pushed Authorization Response.
type PushedAuthorizationResponse struct {
	// ExpiresIn A JSON number that represents the lifetime of the request URI in seconds as a positive integer. The request URI lifetime is at the discretion of the authorization server but will typically be relatively short (e.g., between 5 and 600 seconds).
	ExpiresIn int `json:"expires_in"`

	// RequestUri The request URI corresponding to the authorization request posted. This URI is a single-use reference to the respective request data in the subsequent authorization request.
	RequestUri string `json:"request_uri"`
}

// RegisterOAuthClientRequest OAuth 2.0 client registration request.
type RegisterOAuthClientRequest struct {
	// ClientName Human-readable string name of the client to be presented to the end-user during authorization.
	ClientName *string `json:"client_name,omitempty"`

	// ClientUri URL string of a web page providing information about the client.
	ClientUri *string `json:"client_uri,omitempty"`

	// Contacts Array of strings representing ways to contact people responsible for this client, typically email addresses.
	Contacts *[]string `json:"contacts,omitempty"`

	// GrantTypes Array of OAuth 2.0 grant types that the client is allowed to use. Supported values: authorization_code, urn:ietf:params:oauth:grant-type:pre-authorized_code.
	GrantTypes *[]string `json:"grant_types,omitempty"`

	// Jwks Client's JSON Web Key Set document value, which contains the client's public keys.
	Jwks *map[string]interface{} `json:"jwks,omitempty"`

	// JwksUri URL string referencing the client's JSON Web Key (JWK) Set document, which contains the client's public keys.
	JwksUri *string `json:"jwks_uri,omitempty"`

	// LogoUri URL string that references a logo for the client.
	LogoUri *string `json:"logo_uri,omitempty"`

	// PolicyUri URL string that points to a human-readable privacy policy document that describes how the deployment organization collects, uses, retains, and discloses personal data.
	PolicyUri *string `json:"policy_uri,omitempty"`

	// RedirectUris Array of allowed redirection URI strings for the client. Required if client supports authorization_code grant type.
	RedirectUris *[]string `json:"redirect_uris,omitempty"`

	// ResponseTypes Array of OAuth 2.0 response types that the client can use at the authorization endpoint. Supported values: code.
	ResponseTypes *[]string `json:"response_types,omitempty"`

	// Scope String containing a space-separated list of scope values that the client can use when requesting access tokens.
	Scope *string `json:"scope,omitempty"`

	// SoftwareId A unique identifier string (e.g. UUID) assigned by the client developer or software publisher used by registration endpoints to identify the client software to be dynamically registered.
	SoftwareId *string `json:"software_id,omitempty"`

	// SoftwareVersion A version identifier string for the client software identified by "software_id".
	SoftwareVersion *string `json:"software_version,omitempty"`

	// TokenEndpointAuthMethod Requested client authentication method for the token endpoint. Supported values: none, client_secret_post, client_secret_basic. None is used for public clients (native apps, mobile apps) which can not have secrets. Default: client_secret_basic.
	TokenEndpointAuthMethod *string `json:"token_endpoint_auth_method,omitempty"`

	// TosUri URL string that points to a human-readable terms of service document for the client that describes a contractual relationship between the end-user and the client that the end-user accepts when authorizing the client.
	TosUri *string `json:"tos_uri,omitempty"`
}

// RegisterOAuthClientResponse Response with registered metadata for created OAuth 2.0 client.
type RegisterOAuthClientResponse struct {
	// ClientId Client identifier.
	ClientId string `json:"client_id"`

	// ClientIdIssuedAt Time at which the client identifier was issued.
	ClientIdIssuedAt int `json:"client_id_issued_at"`

	// ClientName Human-readable string name of the client to be presented to the end-user during authorization.
	ClientName *string `json:"client_name,omitempty"`

	// ClientSecret Client secret. This value is used by the confidential client to authenticate to the token endpoint.
	ClientSecret *string `json:"client_secret,omitempty"`

	// ClientSecretExpiresAt Time at which the client secret will expire or 0 if it will not expire.
	ClientSecretExpiresAt *int `json:"client_secret_expires_at,omitempty"`

	// ClientUri URL string of a web page providing information about the client.
	ClientUri *string `json:"client_uri,omitempty"`

	// Contacts Array of strings representing ways to contact people responsible for this client, typically email addresses.
	Contacts *[]string `json:"contacts,omitempty"`

	// GrantTypes Array of OAuth 2.0 grant types that the client is allowed to use. Supported values: authorization_code, urn:ietf:params:oauth:grant-type:pre-authorized_code.
	GrantTypes []string `json:"grant_types"`

	// Jwks Client's JSON Web Key Set document value, which contains the client's public keys.
	Jwks *map[string]interface{} `json:"jwks,omitempty"`

	// JwksUri URL string referencing the client's JSON Web Key (JWK) Set document, which contains the client's public keys.
	JwksUri *string `json:"jwks_uri,omitempty"`

	// LogoUri URL string that references a logo for the client.
	LogoUri *string `json:"logo_uri,omitempty"`

	// PolicyUri URL string that points to a human-readable privacy policy document that describes how the deployment organization collects, uses, retains, and discloses personal data.
	PolicyUri *string `json:"policy_uri,omitempty"`

	// RedirectUris Array of allowed redirection URI strings for the client. Required if client supports authorization_code grant type.
	RedirectUris *[]string `json:"redirect_uris,omitempty"`

	// ResponseTypes Array of OAuth 2.0 response types that the client can use at the authorization endpoint. Supported values: code.
	ResponseTypes *[]string `json:"response_types,omitempty"`

	// Scope String containing a space-separated list of scope values that the client can use when requesting access tokens.
	Scope *string `json:"scope,omitempty"`

	// SoftwareId A unique identifier string (e.g. UUID) assigned by the client developer or software publisher used by registration endpoints to identify the client software to be dynamically registered.
	SoftwareId *string `json:"software_id,omitempty"`

	// SoftwareVersion A version identifier string for the client software identified by "software_id".
	SoftwareVersion *string `json:"software_version,omitempty"`

	// TokenEndpointAuthMethod Requested client authentication method for the token endpoint. Supported values: none, client_secret_post, client_secret_basic. None is used for public clients (native apps, mobile apps) which can not have secrets. Default: client_secret_basic.
	TokenEndpointAuthMethod string `json:"token_endpoint_auth_method"`

	// TosUri URL string that points to a human-readable terms of service document for the client that describes a contractual relationship between the end-user and the client that the end-user accepts when authorizing the client.
	TosUri *string `json:"tos_uri,omitempty"`
}

// OidcAuthorizeParams defines parameters for OidcAuthorize.
type OidcAuthorizeParams struct {
	// ResponseType Value MUST be set to "code".
	ResponseType string `form:"response_type" json:"response_type"`

	// ClientId The client identifier.
	ClientId string `form:"client_id" json:"client_id"`

	// CodeChallenge A challenge derived from the code verifier that is sent in the authorization request, to be verified against later.
	CodeChallenge string `form:"code_challenge" json:"code_challenge"`

	// CodeChallengeMethod A method that was used to derive code challenge.
	CodeChallengeMethod *string `form:"code_challenge_method,omitempty" json:"code_challenge_method,omitempty"`

	// RedirectUri The authorization server redirects the user-agent to the client's redirection endpoint previously established with the authorization server during the client registration process or when making the authorization request.
	RedirectUri *string `form:"redirect_uri,omitempty" json:"redirect_uri,omitempty"`

	// Scope The scope of the access request.
	Scope *string `form:"scope,omitempty" json:"scope,omitempty"`

	// State An opaque value used by the client to maintain state between the request and callback. The authorization server includes this value when redirecting the user-agent back to the client. The parameter SHOULD be used for preventing cross-site request forgery.
	State *string `form:"state,omitempty" json:"state,omitempty"`

	// AuthorizationDetails Encoded array of the authorization_details conveys the details about the credentials the wallet wants to obtain. Multiple authorization_details can be used with type openid_credential to request authorization in case of multiple credentials.
	AuthorizationDetails *string `form:"authorization_details,omitempty" json:"authorization_details,omitempty"`

	// WalletIssuer Wallet's OpenID Connect Issuer URL. The Issuer will use the discovery process to determine the wallet's capabilities and endpoints. RECOMMENDED in Dynamic Credential Request.
	WalletIssuer *string `form:"wallet_issuer,omitempty" json:"wallet_issuer,omitempty"`

	// UserHint An opaque user hint the wallet MAY use in subsequent callbacks to optimize the user's experience. RECOMMENDED in Dynamic Credential Request.
	UserHint *string `form:"user_hint,omitempty" json:"user_hint,omitempty"`

	// IssuerState String value identifying a certain processing context at the credential issuer. A value for this parameter is typically passed in an issuance initiation request from the issuer to the wallet. This request parameter is used to pass the  issuer_state value back to the credential issuer. The issuer must take into account that op_state is not guaranteed to originate from this issuer, could be an attack.
	IssuerState *string `form:"issuer_state,omitempty" json:"issuer_state,omitempty"`

	// ClientIdScheme String indicating that client is using an identifier not assigned by the authorization server. The only supported value "urn:ietf:params:oauth:client-id-scheme:oauth-discoverable-client" specifies "client_id" parameter in the request as an HTTPS based URL corresponding to the "client_uri". If the authorization server does not already have the metadata for the identified client, it can retrieve the metadata from client’s well-known location.
	ClientIdScheme *string `form:"client_id_scheme,omitempty" json:"client_id_scheme,omitempty"`
}

// OidcPushedAuthorizationRequestFormdataBody defines parameters for OidcPushedAuthorizationRequest.
type OidcPushedAuthorizationRequestFormdataBody struct {
	// AuthorizationDetails Encoded array of authorization_details conveys the details about the credentials the wallet wants to obtain. Multiple authorization_details can be used with type openid_credential to request authorization in case of multiple credentials.
	AuthorizationDetails *string `form:"authorization_details,omitempty" json:"authorization_details,omitempty"`

	// ClientId The client identifier.
	ClientId string `form:"client_id" json:"client_id"`

	// CodeChallenge A challenge derived from the code verifier that is sent in the authorization request, to be verified against later.
	CodeChallenge string `form:"code_challenge" json:"code_challenge"`

	// CodeChallengeMethod A method that was used to derive code challenge.
	CodeChallengeMethod *string `form:"code_challenge_method,omitempty" json:"code_challenge_method,omitempty"`

	// OpState String value identifying a certain processing context at the credential issuer. A value for this parameter is typically passed in an issuance initiation request from the issuer to the wallet. This request parameter is used to pass the  op_state value back to the credential issuer. The issuer must take into account that op_state is not guaranteed to originate from this issuer, could be an attack.
	OpState *string `form:"op_state,omitempty" json:"op_state,omitempty"`

	// RedirectUri The authorization server redirects the user-agent to the client's redirection endpoint previously established with the authorization server during the client registration process or when making the authorization request.
	RedirectUri *string `form:"redirect_uri,omitempty" json:"redirect_uri,omitempty"`

	// ResponseType Value MUST be set to "code".
	ResponseType string `form:"response_type" json:"response_type"`

	// Scope The scope of the access request.
	Scope *string `form:"scope,omitempty" json:"scope,omitempty"`

	// State An opaque value used by the client to maintain state between the request and callback. The authorization server includes this value when redirecting the user-agent back to the client. The parameter SHOULD be used for preventing cross-site request forgery.
	State *string `form:"state,omitempty" json:"state,omitempty"`

	// UserHint An opaque user hint the wallet MAY use in subsequent callbacks to optimize the user's experience. RECOMMENDED in Dynamic Credential Request.
	UserHint *string `form:"user_hint,omitempty" json:"user_hint,omitempty"`

	// WalletIssuer Wallet's OpenID Connect Issuer URL. The Issuer will use the discovery process to determine the wallet's capabilities and endpoints. RECOMMENDED in Dynamic Credential Request.
	WalletIssuer *string `form:"wallet_issuer,omitempty" json:"wallet_issuer,omitempty"`
}

// OidcRedirectParams defines parameters for OidcRedirect.
type OidcRedirectParams struct {
	// Code auth code for issuer provider
	Code string `form:"code" json:"code"`

	// State state
	State string `form:"state" json:"state"`
}

// OidcTokenFormdataBody defines parameters for OidcToken.
type OidcTokenFormdataBody struct {
	// ClientId REQUIRED, if the client is not authenticating with the authorization server.
	ClientId *string `form:"client_id" json:"client_id"`

	// Code The authorization code received from the authorization server.
	Code *string `form:"code" json:"code"`

	// CodeVerifier A cryptographically random string that is used to correlate the authorization request to the token request.
	CodeVerifier *string `form:"code_verifier" json:"code_verifier"`

	// GrantType Value MUST be set to "authorization_code".
	GrantType string `form:"grant_type" json:"grant_type"`

	// PreAuthorizedCode REQUIRED, if pre-auth flow
	PreAuthorizedCode *string `form:"pre-authorized_code" json:"pre-authorized_code"`

	// RedirectUri REQUIRED, if the "redirect_uri" parameter was included in the authorization request, and their values MUST be identical.
	RedirectUri *string `form:"redirect_uri" json:"redirect_uri"`

	// TxCode REQUIRED, if pre-auth flow and tx_code was present in the Credential Offer.
	TxCode *string `form:"tx_code" json:"tx_code"`
}

// OidcBatchCredentialJSONRequestBody defines body for OidcBatchCredential for application/json ContentType.
type OidcBatchCredentialJSONRequestBody = BatchCredentialRequest

// OidcCredentialJSONRequestBody defines body for OidcCredential for application/json ContentType.
type OidcCredentialJSONRequestBody = CredentialRequest

// OidcAcknowledgementJSONRequestBody defines body for OidcAcknowledgement for application/json ContentType.
type OidcAcknowledgementJSONRequestBody = AckRequest

// OidcPushedAuthorizationRequestFormdataRequestBody defines body for OidcPushedAuthorizationRequest for application/x-www-form-urlencoded ContentType.
type OidcPushedAuthorizationRequestFormdataRequestBody OidcPushedAuthorizationRequestFormdataBody

// OidcTokenFormdataRequestBody defines body for OidcToken for application/x-www-form-urlencoded ContentType.
type OidcTokenFormdataRequestBody OidcTokenFormdataBody

// OidcRegisterClientJSONRequestBody defines body for OidcRegisterClient for application/json ContentType.
type OidcRegisterClientJSONRequestBody = RegisterOAuthClientRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// OIDC Authorization Request
	// (GET /oidc/authorize)
	OidcAuthorize(ctx echo.Context, params OidcAuthorizeParams) error
	// OIDC Batch Credential
	// (POST /oidc/batch_credential)
	OidcBatchCredential(ctx echo.Context) error
	// OIDC Credential
	// (POST /oidc/credential)
	OidcCredential(ctx echo.Context) error
	// OIDC Notification
	// (POST /oidc/notification)
	OidcAcknowledgement(ctx echo.Context) error
	// OIDC Pushed Authorization Request
	// (POST /oidc/par)
	OidcPushedAuthorizationRequest(ctx echo.Context) error
	// OIDC Redirect
	// (GET /oidc/redirect)
	OidcRedirect(ctx echo.Context, params OidcRedirectParams) error
	// OIDC Token Request
	// (POST /oidc/token)
	OidcToken(ctx echo.Context) error
	// OIDC Register OAuth Client
	// (POST /oidc/{profileID}/{profileVersion}/register)
	OidcRegisterClient(ctx echo.Context, profileID string, profileVersion string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// OidcAuthorize converts echo context to params.
func (w *ServerInterfaceWrapper) OidcAuthorize(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params OidcAuthorizeParams
	// ------------- Required query parameter "response_type" -------------

	err = runtime.BindQueryParameter("form", true, true, "response_type", ctx.QueryParams(), &params.ResponseType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter response_type: %s", err))
	}

	// ------------- Required query parameter "client_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "client_id", ctx.QueryParams(), &params.ClientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter client_id: %s", err))
	}

	// ------------- Required query parameter "code_challenge" -------------

	err = runtime.BindQueryParameter("form", true, true, "code_challenge", ctx.QueryParams(), &params.CodeChallenge)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code_challenge: %s", err))
	}

	// ------------- Optional query parameter "code_challenge_method" -------------

	err = runtime.BindQueryParameter("form", true, false, "code_challenge_method", ctx.QueryParams(), &params.CodeChallengeMethod)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code_challenge_method: %s", err))
	}

	// ------------- Optional query parameter "redirect_uri" -------------

	err = runtime.BindQueryParameter("form", true, false, "redirect_uri", ctx.QueryParams(), &params.RedirectUri)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter redirect_uri: %s", err))
	}

	// ------------- Optional query parameter "scope" -------------

	err = runtime.BindQueryParameter("form", true, false, "scope", ctx.QueryParams(), &params.Scope)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scope: %s", err))
	}

	// ------------- Optional query parameter "state" -------------

	err = runtime.BindQueryParameter("form", true, false, "state", ctx.QueryParams(), &params.State)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter state: %s", err))
	}

	// ------------- Optional query parameter "authorization_details" -------------

	err = runtime.BindQueryParameter("form", true, false, "authorization_details", ctx.QueryParams(), &params.AuthorizationDetails)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter authorization_details: %s", err))
	}

	// ------------- Optional query parameter "wallet_issuer" -------------

	err = runtime.BindQueryParameter("form", true, false, "wallet_issuer", ctx.QueryParams(), &params.WalletIssuer)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter wallet_issuer: %s", err))
	}

	// ------------- Optional query parameter "user_hint" -------------

	err = runtime.BindQueryParameter("form", true, false, "user_hint", ctx.QueryParams(), &params.UserHint)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_hint: %s", err))
	}

	// ------------- Optional query parameter "issuer_state" -------------

	err = runtime.BindQueryParameter("form", true, false, "issuer_state", ctx.QueryParams(), &params.IssuerState)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter issuer_state: %s", err))
	}

	// ------------- Optional query parameter "client_id_scheme" -------------

	err = runtime.BindQueryParameter("form", true, false, "client_id_scheme", ctx.QueryParams(), &params.ClientIdScheme)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter client_id_scheme: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OidcAuthorize(ctx, params)
	return err
}

// OidcBatchCredential converts echo context to params.
func (w *ServerInterfaceWrapper) OidcBatchCredential(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OidcBatchCredential(ctx)
	return err
}

// OidcCredential converts echo context to params.
func (w *ServerInterfaceWrapper) OidcCredential(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OidcCredential(ctx)
	return err
}

// OidcAcknowledgement converts echo context to params.
func (w *ServerInterfaceWrapper) OidcAcknowledgement(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OidcAcknowledgement(ctx)
	return err
}

// OidcPushedAuthorizationRequest converts echo context to params.
func (w *ServerInterfaceWrapper) OidcPushedAuthorizationRequest(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OidcPushedAuthorizationRequest(ctx)
	return err
}

// OidcRedirect converts echo context to params.
func (w *ServerInterfaceWrapper) OidcRedirect(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params OidcRedirectParams
	// ------------- Required query parameter "code" -------------

	err = runtime.BindQueryParameter("form", true, true, "code", ctx.QueryParams(), &params.Code)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
	}

	// ------------- Required query parameter "state" -------------

	err = runtime.BindQueryParameter("form", true, true, "state", ctx.QueryParams(), &params.State)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter state: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OidcRedirect(ctx, params)
	return err
}

// OidcToken converts echo context to params.
func (w *ServerInterfaceWrapper) OidcToken(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OidcToken(ctx)
	return err
}

// OidcRegisterClient converts echo context to params.
func (w *ServerInterfaceWrapper) OidcRegisterClient(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "profileID" -------------
	var profileID string

	err = runtime.BindStyledParameterWithOptions("simple", "profileID", ctx.Param("profileID"), &profileID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter profileID: %s", err))
	}

	// ------------- Path parameter "profileVersion" -------------
	var profileVersion string

	err = runtime.BindStyledParameterWithOptions("simple", "profileVersion", ctx.Param("profileVersion"), &profileVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter profileVersion: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.OidcRegisterClient(ctx, profileID, profileVersion)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/oidc/authorize", wrapper.OidcAuthorize)
	router.POST(baseURL+"/oidc/batch_credential", wrapper.OidcBatchCredential)
	router.POST(baseURL+"/oidc/credential", wrapper.OidcCredential)
	router.POST(baseURL+"/oidc/notification", wrapper.OidcAcknowledgement)
	router.POST(baseURL+"/oidc/par", wrapper.OidcPushedAuthorizationRequest)
	router.GET(baseURL+"/oidc/redirect", wrapper.OidcRedirect)
	router.POST(baseURL+"/oidc/token", wrapper.OidcToken)
	router.POST(baseURL+"/oidc/:profileID/:profileVersion/register", wrapper.OidcRegisterClient)

}
