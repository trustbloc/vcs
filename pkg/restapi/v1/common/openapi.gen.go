// Package common provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package common

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
)

// Defines values for DIDMethod.
const (
	DIDMethodKey DIDMethod = "key"
	DIDMethodOrb DIDMethod = "orb"
	DIDMethodWeb DIDMethod = "web"
)

// Defines values for KMSConfigType.
const (
	KMSConfigTypeAws   KMSConfigType = "aws"
	KMSConfigTypeLocal KMSConfigType = "local"
	KMSConfigTypeWeb   KMSConfigType = "web"
)

// Defines values for VCFormat.
const (
	CwtVcLd     VCFormat = "cwt_vc-ld"
	JwtVcJson   VCFormat = "jwt_vc_json"
	JwtVcJsonLd VCFormat = "jwt_vc_json-ld"
	LdpVc       VCFormat = "ldp_vc"
)

// Defines values for VPFormat.
const (
	CwtVp VPFormat = "cwt_vp"
	JwtVp VPFormat = "jwt_vp"
	LdpVp VPFormat = "ldp_vp"
)

// AuthorizationDetails Model to convey the details about the Credentials the Client wants to obtain.
type AuthorizationDetails struct {
	// CredentialConfigurationId REQUIRED when Format parameter is not present. String specifying a unique identifier of the Credential being described in the credential_configurations_supported map in the Credential Issuer Metadata. The referenced object in the credential_configurations_supported map conveys the details, such as the format, for issuance of the requested Credential. It MUST NOT be present if format parameter is present.
	CredentialConfigurationId *string `json:"credential_configuration_id,omitempty"`

	// CredentialDefinition Object containing the detailed description of the credential type.
	CredentialDefinition *CredentialDefinition `json:"credential_definition,omitempty"`

	// CredentialIdentifiers For Token response only. Array of strings, each uniquely identifying a Credential that can be issued using the Access Token returned in this response. Each of these Credentials corresponds to the same entry in the credential_configurations_supported Credential Issuer metadata but can contain different claim values or a different subset of claims within the claims set identified by that Credential type.
	CredentialIdentifiers *[]string `json:"credential_identifiers,omitempty"`

	// Format REQUIRED when CredentialConfigurationId parameter is not present. String identifying the format of the Credential the Wallet needs. This Credential format identifier determines further claims in the authorization details object needed to identify the Credential type in the requested format. It MUST NOT be present if credential_configuration_id parameter is present.
	Format *string `json:"format,omitempty"`

	// Locations An array of strings that allows a client to specify the location of the resource server(s) allowing the Authorization Server to mint audience restricted access tokens.
	Locations *[]string `json:"locations,omitempty"`

	// Type String that determines the authorization details type. MUST be set to "openid_credential" for OIDC4VC.
	Type string `json:"type"`
}

// CredentialDefinition Object containing the detailed description of the credential type.
type CredentialDefinition struct {
	// Context For ldp_vc only. Array as defined in https://www.w3.org/TR/vc-data-model/#contexts.
	Context *[]string `json:"@context,omitempty"`

	// CredentialSubject An object containing a list of name/value pairs, where each name identifies a claim offered in the Credential. The value can be another such object (nested data structures), or an array of such objects.
	CredentialSubject *map[string]interface{} `json:"credentialSubject,omitempty"`

	// Type Array designating the types a certain credential type supports
	Type []string `json:"type"`
}

// CredentialResponseCredentialObject Model for credentials field from credential response.
type CredentialResponseCredentialObject struct {
	Credential any `json:"credential"`
}

// DIDMethod DID method of the DID to be used for signing.
type DIDMethod string

// KMSConfig Model for KMS configuration.
type KMSConfig struct {
	// DbPrefix Prefix of database used by local kms.
	DbPrefix *string `json:"dbPrefix,omitempty"`

	// DbType Type of database used by local kms.
	DbType *string `json:"dbType,omitempty"`

	// DbURL URL to database used by local kms.
	DbURL *string `json:"dbURL,omitempty"`

	// Endpoint KMS endpoint.
	Endpoint *string `json:"endpoint,omitempty"`

	// SecretLockKeyPath Path to secret lock used by local kms.
	SecretLockKeyPath *string `json:"secretLockKeyPath,omitempty"`

	// Type Type of kms used to create and store DID keys.
	Type KMSConfigType `json:"type"`
}

// KMSConfigType Type of kms used to create and store DID keys.
type KMSConfigType string

// VCFormat Supported VC formats.
type VCFormat string

// VPFormat Supported VP formats.
type VPFormat string

// WalletInitiatedFlowData defines model for WalletInitiatedFlowData.
type WalletInitiatedFlowData struct {
	ClaimEndpoint        string    `json:"claim_endpoint"`
	CredentialTemplateId string    `json:"credential_template_id"`
	OpState              string    `json:"op_state"`
	ProfileId            string    `json:"profile_id"`
	ProfileVersion       string    `json:"profile_version"`
	Scopes               *[]string `json:"scopes"`
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"gqskbYKYsGB+/i8AAP//GezTPHUTAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
