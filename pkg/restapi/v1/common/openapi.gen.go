// Package common provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package common

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
)

// Defines values for DIDMethod.
const (
	DIDMethodKey DIDMethod = "key"
	DIDMethodOrb DIDMethod = "orb"
	DIDMethodWeb DIDMethod = "web"
)

// Defines values for KMSConfigType.
const (
	KMSConfigTypeAws   KMSConfigType = "aws"
	KMSConfigTypeLocal KMSConfigType = "local"
	KMSConfigTypeWeb   KMSConfigType = "web"
)

// Defines values for VCFormat.
const (
	JwtVcJson   VCFormat = "jwt_vc_json"
	JwtVcJsonLd VCFormat = "jwt_vc_json-ld"
	LdpVc       VCFormat = "ldp_vc"
)

// Defines values for VPFormat.
const (
	JwtVp VPFormat = "jwt_vp"
	LdpVp VPFormat = "ldp_vp"
)

// Model to convey the details about the Credentials the Client wants to obtain.
type AuthorizationDetails struct {
	// REQUIRED when Format parameter is not present. String specifying a unique identifier of the Credential being described in the credential_configurations_supported map in the Credential Issuer Metadata. The referenced object in the credential_configurations_supported map conveys the details, such as the format, for issuance of the requested Credential. It MUST NOT be present if format parameter is present.
	CredentialConfigurationId *string `json:"credential_configuration_id,omitempty"`

	// Object containing the detailed description of the credential type.
	CredentialDefinition *CredentialDefinition `json:"credential_definition,omitempty"`

	// For Token response only. Array of strings, each uniquely identifying a Credential that can be issued using the Access Token returned in this response. Each of these Credentials corresponds to the same entry in the credential_configurations_supported Credential Issuer metadata but can contain different claim values or a different subset of claims within the claims set identified by that Credential type.
	CredentialIdentifiers *[]string `json:"credential_identifiers,omitempty"`

	// REQUIRED when CredentialConfigurationId parameter is not present. String identifying the format of the Credential the Wallet needs. This Credential format identifier determines further claims in the authorization details object needed to identify the Credential type in the requested format. It MUST NOT be present if credential_configuration_id parameter is present.
	Format *string `json:"format,omitempty"`

	// An array of strings that allows a client to specify the location of the resource server(s) allowing the Authorization Server to mint audience restricted access tokens.
	Locations *[]string `json:"locations,omitempty"`

	// String that determines the authorization details type. MUST be set to "openid_credential" for OIDC4VC.
	Type string `json:"type"`
}

// Object containing the detailed description of the credential type.
type CredentialDefinition struct {
	// For ldp_vc only. Array as defined in https://www.w3.org/TR/vc-data-model/#contexts.
	Context *[]string `json:"@context,omitempty"`

	// An object containing a list of name/value pairs, where each name identifies a claim offered in the Credential. The value can be another such object (nested data structures), or an array of such objects.
	CredentialSubject *map[string]interface{} `json:"credentialSubject,omitempty"`

	// Array designating the types a certain credential type supports
	Type []string `json:"type"`
}

// DID method of the DID to be used for signing.
type DIDMethod string

// Model for KMS configuration.
type KMSConfig struct {
	// Prefix of database used by local kms.
	DbPrefix *string `json:"dbPrefix,omitempty"`

	// Type of database used by local kms.
	DbType *string `json:"dbType,omitempty"`

	// URL to database used by local kms.
	DbURL *string `json:"dbURL,omitempty"`

	// KMS endpoint.
	Endpoint *string `json:"endpoint,omitempty"`

	// Path to secret lock used by local kms.
	SecretLockKeyPath *string `json:"secretLockKeyPath,omitempty"`

	// Type of kms used to create and store DID keys.
	Type KMSConfigType `json:"type"`
}

// Type of kms used to create and store DID keys.
type KMSConfigType string

// Supported VC formats.
type VCFormat string

// Supported VP formats.
type VPFormat string

// WalletInitiatedFlowData defines model for WalletInitiatedFlowData.
type WalletInitiatedFlowData struct {
	ClaimEndpoint        string    `json:"claim_endpoint"`
	CredentialTemplateId string    `json:"credential_template_id"`
	OpState              string    `json:"op_state"`
	ProfileId            string    `json:"profile_id"`
	ProfileVersion       string    `json:"profile_version"`
	Scopes               *[]string `json:"scopes"`
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/5xXX2/bOBL/KgPuPbSAYhfXffLT5ewUMNpsc3HqfbhdGBQ5jthIpJYcxfUV/e6HISVb",
	"juQ02ZfE4p/5+5vfDL8L5araWbQUxOy7CKrASsaflw0Vzpv/STLOLpCkKeO6xqC8qXlVzMS101gCOVDO",
	"PuIeqEDQ6TDI3DUUV+YeNVoysgzpuzRoCXbSUuDLLidp7ERkovauRk8Goy51uLdRzm7NfeOjORujh6bc",
	"Xv3ny/L2agG7Ai18cL6SBLX0skJCDyaAdQS1x4CWJrAib+w9hBqV2e75p4TGmr8aBBOVbg16cNsnDkCO",
	"fDapzlGDsfHEOVPDJjR17TyhhkrW3fGewGUIDXq4RpJakpzAXYHgcYserUINLv+Kil6rJ+Uj9BOSQWhU",
	"ATItbmOAMv4PJoRGWoWdux7/ajCwqKOdE1gSXH9Z3cFvn+8gxy6SYLatrNNgd4EWmaB9jWImQoy4+JH1",
	"86pxa6xJKfwu/uFxK2bil+kRltMWk9OjKYvjnVNhx8SNQPWD83DnHtCCx1A7GxCcLfcTuPRe7tn1ZGDI",
	"AKUqWjCU+w4OLUZ6maNCEihpORocQtTQBD7FMbxUCkM4aKTG2w4tJhxMmMAV60pxD6eVopxPx3QsEhYa",
	"ZIWAlvz+NXgYgq1qwQZ5kzxQznIJgjbbCDwCVUpTwaMsGwzgPMjeXmjygMRWx1MBdoaKzqC0wvuHdGjI",
	"9yla/ejta2R0GMIqpmsAk3ZBcn74O8HsZ5V/VDHvB2Spf04G/Uwfa2SEBPjzd1mWSGARdeCiNaF/or3a",
	"oxLNmitjMcC28VSg72LVRk72GffAom35sxrUjIPOyIFN+xo7UccCTnY8V7zPkOzLK7p0KsFumJ1LC/JJ",
	"hSUsyLJ0uwASVGoH5Do2jj50Io+kFFzjFUJA/4j+TXibJBwK7iR8q3iIZVbGEshGG6ZTlkLeKA6NTBVK",
	"XKHhdUhM3089bVEUnetl+3xuYwmkvOQYS4Yc/CFcjdbozTExf4hI05+Xi/mv6/lIAn5kglNuPGox+2/a",
	"/TMTZKjkY6O9/CAkIYzdGqXYgZufEyJbyujCn3xCDb3DXerUsOpPG/2/WBh+o3HWLnW9eVQnbC0DxM6R",
	"KLUgqsNsOt3tdpPd+4nz99O72+mjumCOu6h4Rpn+0qp4ZaaPpq+aFKcxgLtBSCSUJkTqsLLCaeRRqKXx",
	"IWOa8piaDG8eSSIVA/Oui1Srh+NCGg+SuLb1SOsim8Tu3lryxqbyjyQfyDeKGo/hbRapvF+Rx0thMoaJ",
	"cainLGgM5t5K6jDAZ6MP6GM3eZJ3aFtSeEUGfoLsMcR2MTiOFkPHMvHtguR9YJmxdXvx549MLJaLa6TC",
	"jYyXi+WC22bhdIdqXiHHGWhCYlrgcBh7z/rQNhVLdz4Xmdgh/33AfTT+qcsfr1epV50bsFn2x+sVnBD0",
	"sIx0fuNxa74NxaR1tpwRkcvQGp3vI8+W8FCFUWLX+d0oAHj1b4n7cvtpKO3L7ScO5SuFodW1M3akJDlW",
	"3e7o1YDKI31y6uEj7m8kFSMhk1TEnhSPsikPL7SLno3YQxWSHH41eZTEFawhkPMJUw+4D30ERWUHDMld",
	"GMHQT8rkCLAXFsJ6/uHMsLU6jJXreTtdnFj7dUebR7X5Gpy9KLXI+gsiE4nL+7YdVI1Ecn3zAjNuzppR",
	"dwrrE4U35xWmoW7JtCEJ9YfS7RaSJOu3TVnKnCWQb3DwVGXa3vQR+dyrh7CqS0nYPmQHR129CSQJRzdr",
	"77amPHu3235EH9r+PYS/cnWy+zwPP/X3WV7u2TS04KAvexqms0HphaCXuXPZGbQtNs/YrRupQt8E+nfp",
	"FKznq64h9RvV4S3MRfmI3mxNO4emt93v7+ewnl9c3ixBls7ex7cPfK7RLhe/rudQe0dOufLwsEY/jWJ4",
	"iLaEXqooLV5LDjFuS6PQhphwngm4xdZSFXjxz8k7kYnGl2Im+nOOjNtx1mnvhumn5fzqt9UV35nQt9S+",
	"u0bpqsrZtkOzaevoGie4/4jgsdkohDfr+eqtyMQBROLdhC2J2EQrayNm4v3kXTSullQEMWPA/Ph/AAAA",
	"///tjedAUhIAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
